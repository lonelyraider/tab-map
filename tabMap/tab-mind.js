/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./tabMap/tab-mind.js":
/*!****************************!*\
  !*** ./tabMap/tab-mind.js ***!
  \****************************/
/***/ (() => {

eval("(() => {\n    var __defProp = Object.defineProperty;\n    var __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\n    var __export = (target, all2) => {\n      __markAsModule(target);\n      for (var name in all2)\n        __defProp(target, name, { get: all2[name], enumerable: true });\n    };\n  \n    // .js/html.js\n    function node(name, attrs) {\n      let node11 = document.createElement(name);\n      Object.assign(node11, attrs);\n      return node11;\n    }\n  \n    // .js/svg.js\n    var NS = \"http://www.w3.org/2000/svg\";\n    function node2(name, attrs) {\n      let node11 = document.createElementNS(NS, name);\n      for (let attr in attrs) {\n        node11.setAttribute(attr, attrs[attr]);\n      }\n      return node11;\n    }\n    function group() {\n      return node2(\"g\");\n    }\n    function foreignObject() {\n      let fo = node2(\"foreignObject\");\n      fo.setAttribute(\"width\", \"1\");\n      fo.setAttribute(\"height\", \"1\");\n      return fo;\n    }\n  \n    // .js/pubsub.js\n    var subscribers = new Map();\n    function publish(message, publisher, data) {\n      let subs = subscribers.get(message) || [];\n      subs.forEach((sub) => {\n        if (typeof sub == \"function\") {\n          sub(message, publisher, data);\n        } else {\n          sub.handleMessage(message, publisher, data);\n        }\n      });\n    }\n    function subscribe(message, subscriber) {\n      if (!subscribers.has(message)) {\n        subscribers.set(message, []);\n      }\n      let subs = subscribers.get(message) || [];\n      let index2 = subs.indexOf(subscriber);\n      if (index2 == -1) {\n        subs.push(subscriber);\n      }\n    }\n    function unsubscribe(message, subscriber) {\n      let subs = subscribers.get(message) || [];\n      let index2 = subs.indexOf(subscriber);\n      if (index2 > -1) {\n        subs.splice(index2, 1);\n      }\n    }\n  \n    // .js/history.js\n    var index = 0;\n    var actions = [];\n    function reset() {\n      index = 0;\n      actions = [];\n    }\n    function push(action2) {\n      if (index < actions.length) {\n        actions.splice(index, actions.length - index);\n      }\n      actions.push(action2);\n      index++;\n    }\n    function back() {\n      actions[--index].undo();\n    }\n    function forward() {\n      actions[index++].do();\n    }\n    function canBack() {\n      return !!index;\n    }\n    function canForward() {\n      return index != actions.length;\n    }\n  \n    // .js/ui/help.js\n    var help_exports = {};\n    __export(help_exports, {\n      close: () => close,\n      init: () => init,\n      toggle: () => toggle\n    });\n    var node3 = document.querySelector(\"#help\");\n    var MAP = {\n      \"Enter\": \"\\u21A9\",\n      \"Space\": \"Spacebar\",\n      \"ArrowLeft\": \"\\u2190\",\n      \"ArrowUp\": \"\\u2191\",\n      \"ArrowRight\": \"\\u2192\",\n      \"ArrowDown\": \"\\u2193\",\n      \"-\": \"\\u2212\"\n    };\n    function toggle() {\n      node3.hidden = !node3.hidden;\n    }\n    function init() {\n      let t = node3.querySelector(\".navigation\");\n      buildRow(t, \"pan\");\n      buildRow(t, \"select\");\n      buildRow(t, \"select-root\");\n      buildRow(t, \"select-parent\");\n      buildRow(t, \"center\");\n      buildRow(t, \"zoom-in\", \"zoom-out\");\n      buildRow(t, \"fold\");\n      t = node3.querySelector(\".manipulation\");\n      buildRow(t, \"insert-sibling\");\n      buildRow(t, \"insert-child\");\n      buildRow(t, \"swap\");\n      buildRow(t, \"side\");\n      buildRow(t, \"delete\");\n      t = node3.querySelector(\".editing\");\n      buildRow(t, \"value\");\n      buildRow(t, \"yes\", \"no\", \"computed\");\n      buildRow(t, \"edit\");\n      buildRow(t, \"newline\");\n      buildRow(t, \"bold\");\n      buildRow(t, \"italic\");\n      buildRow(t, \"underline\");\n      buildRow(t, \"strikethrough\");\n      t = node3.querySelector(\".other\");\n      buildRow(t, \"undo\", \"redo\");\n      buildRow(t, \"save\");\n      buildRow(t, \"save-as\");\n      buildRow(t, \"load\");\n      buildRow(t, \"help\");\n      buildRow(t, \"notes\");\n      buildRow(t, \"ui\");\n    }\n    function buildRow(table, ...commandNames) {\n      var row = table.insertRow(-1);\n      let labels = [];\n      let keys = [];\n      commandNames.forEach((name) => {\n        let command = repo.get(name);\n        if (!command) {\n          console.warn(name);\n          return;\n        }\n        labels.push(command.label);\n        keys = keys.concat(command.keys.map(formatKey));\n      });\n      row.insertCell(-1).textContent = labels.join(\"/\");\n      row.insertCell(-1).textContent = keys.join(\"/\");\n    }\n    function formatKey(key) {\n      var str = \"\";\n      if (key.ctrlKey) {\n        str += \"Ctrl+\";\n      }\n      if (key.altKey) {\n        str += \"Alt+\";\n      }\n      if (key.shiftKey) {\n        str += \"Shift+\";\n      }\n      if (key.key) {\n        let ch = key.key;\n        str += MAP[ch] || ch.toUpperCase();\n      }\n      if (key.code) {\n        let code = key.code;\n        if (code.startsWith(\"Key\")) {\n          str += code.substring(3);\n        } else {\n          str += MAP[code] || code;\n        }\n      }\n      return str;\n    }\n    function close() {\n      node3.hidden = true;\n    }\n  \n    // .js/ui/notes.js\n    var notes_exports = {};\n    __export(notes_exports, {\n      close: () => close2,\n      init: () => init2,\n      toggle: () => toggle2\n    });\n    var node4 = document.querySelector(\"#notes\");\n    var iframe = node4.querySelector(\"iframe\");\n    function toggle2() {\n      node4.hidden = !node4.hidden;\n    }\n    function close2() {\n      if (node4.hidden) {\n        return;\n      }\n      node4.hidden = true;\n    }\n    function onMessage(e) {\n      if (!e.data || !e.data.action) {\n        return;\n      }\n      switch (e.data.action) {\n        case \"setContent\":\n          currentItem.notes = e.data.value.trim();\n          break;\n        case \"closeEditor\":\n          close2();\n          break;\n      }\n    }\n    function init2() {\n      subscribe(\"item-select\", (_message, publisher) => {\n        iframe.contentWindow && iframe.contentWindow.postMessage({\n          action: \"setContent\",\n          value: publisher.notes\n        }, \"*\");\n      });\n      window.addEventListener(\"message\", onMessage);\n    }\n  \n    // .js/ui/color.js\n    var color_exports = {};\n    __export(color_exports, {\n      init: () => init3\n    });\n  \n    // .js/action.js\n    var Action = class {\n      do() {\n      }\n      undo() {\n      }\n    };\n    var Multi = class extends Action {\n      constructor(actions13) {\n        super();\n        this.actions = actions13;\n      }\n      do() {\n        this.actions.forEach((action2) => action2.do());\n      }\n      undo() {\n        this.actions.slice().reverse().forEach((action2) => action2.undo());\n      }\n    };\n    var InsertNewItem = class extends Action {\n      constructor(parent, index2) {\n        super();\n        this.parent = parent;\n        this.index = index2;\n        this.item = new Item();\n      }\n      do() {\n        this.parent.collapsed = false;\n        this.parent.insertChild(this.item, this.index);\n        selectItem(this.item);\n      }\n      undo() {\n        this.parent.removeChild(this.item);\n        selectItem(this.parent);\n      }\n    };\n    var AppendItem = class extends Action {\n      constructor(parent, item) {\n        super();\n        this.parent = parent;\n        this.item = item;\n      }\n      do() {\n        this.parent.insertChild(this.item);\n        selectItem(this.item);\n      }\n      undo() {\n        this.parent.removeChild(this.item);\n        selectItem(this.parent);\n      }\n    };\n    var RemoveItem = class extends Action {\n      constructor(item) {\n        super();\n        this.item = item;\n        this.parent = item.parent;\n        this.index = this.parent.children.indexOf(this.item);\n      }\n      do() {\n        this.parent.removeChild(this.item);\n        selectItem(this.parent);\n      }\n      undo() {\n        this.parent.insertChild(this.item, this.index);\n        selectItem(this.item);\n      }\n    };\n    var MoveItem = class extends Action {\n      constructor(item, newParent, newIndex, newSide = null) {\n        super();\n        this.item = item;\n        this.newParent = newParent;\n        this.newIndex = newIndex;\n        this.newSide = newSide;\n        this.oldParent = item.parent;\n        this.oldIndex = this.oldParent.children.indexOf(item);\n        this.oldSide = item.side;\n      }\n      do() {\n        const { item, newParent, newIndex, newSide } = this;\n        item.side = newSide;\n        if (newIndex === void 0) {\n          newParent.insertChild(item);\n        } else {\n          newParent.insertChild(item, newIndex);\n        }\n        selectItem(item);\n      }\n      undo() {\n        const { item, oldSide, oldIndex, oldParent, newParent } = this;\n        item.side = oldSide;\n        oldParent.insertChild(item, oldIndex);\n        selectItem(newParent);\n      }\n    };\n    var Swap = class extends Action {\n      constructor(item, diff) {\n        super();\n        this.item = item;\n        this.parent = item.parent;\n        let children = this.parent.children;\n        let sibling = this.parent.resolvedLayout.pickSibling(item, diff);\n        this.sourceIndex = children.indexOf(item);\n        this.targetIndex = children.indexOf(sibling);\n      }\n      do() {\n        this.parent.insertChild(this.item, this.targetIndex);\n      }\n      undo() {\n        this.parent.insertChild(this.item, this.sourceIndex);\n      }\n    };\n    var SetLayout = class extends Action {\n      constructor(item, layout) {\n        super();\n        this.item = item;\n        this.layout = layout;\n        this.oldLayout = item.layout;\n      }\n      do() {\n        this.item.layout = this.layout;\n      }\n      undo() {\n        this.item.layout = this.oldLayout;\n      }\n    };\n    var SetShape = class extends Action {\n      constructor(item, shape) {\n        super();\n        this.item = item;\n        this.shape = shape;\n        this.oldShape = item.shape;\n      }\n      do() {\n        this.item.shape = this.shape;\n      }\n      undo() {\n        this.item.shape = this.oldShape;\n      }\n    };\n    var SetColor = class extends Action {\n      constructor(item, color) {\n        super();\n        this.item = item;\n        this.color = color;\n        this.oldColor = item.color;\n      }\n      do() {\n        this.item.color = this.color;\n      }\n      undo() {\n        this.item.color = this.oldColor;\n      }\n    };\n    var SetTextColor = class extends Action {\n      constructor(item, textColor) {\n        super();\n        this.item = item;\n        this.textColor = textColor;\n        this.oldTextColor = item.textColor;\n      }\n      do() {\n        this.item.textColor = this.textColor;\n      }\n      undo() {\n        this.item.textColor = this.oldTextColor;\n      }\n    };\n    var SetText = class extends Action {\n      constructor(item, text) {\n        super();\n        this.item = item;\n        this.text = text;\n        this.oldText = item.text;\n        this.oldValue = item.value;\n      }\n      do() {\n        this.item.text = this.text;\n        console.log(\"here is text pranita\",this.text)\n        let numText = Number(this.text);\n        if (String(numText) == this.text) {\n          this.item.value = numText;\n        }\n      }\n      undo() {\n        this.item.text = this.oldText;\n        this.item.value = this.oldValue;\n      }\n    };\n    var SetValue = class extends Action {\n      constructor(item, value) {\n        super();\n        this.item = item;\n        this.value = value;\n        this.oldValue = item.value;\n      }\n      do() {\n        this.item.value = this.value;\n      }\n      undo() {\n        this.item.value = this.oldValue;\n      }\n    };\n    var SetStatus = class extends Action {\n      constructor(item, status) {\n        super();\n        this.item = item;\n        this.status = status;\n        this.oldStatus = item.status;\n      }\n      do() {\n        this.item.status = this.status;\n      }\n      undo() {\n        this.item.status = this.oldStatus;\n      }\n    };\n    var SetIcon = class extends Action {\n      constructor(item, icon) {\n        super();\n        this.item = item;\n        this.icon = icon;\n        this.oldIcon = item.icon;\n      }\n      do() {\n        this.item.icon = this.icon;\n      }\n      undo() {\n        this.item.icon = this.oldIcon;\n      }\n    };\n    var SetSide = class extends Action {\n      constructor(item, side) {\n        super();\n        this.item = item;\n        this.side = side;\n        this.oldSide = item.side;\n      }\n      do() {\n        this.item.side = this.side;\n        this.item.update({ children: true });\n      }\n      undo() {\n        this.item.side = this.oldSide;\n        this.item.update({ children: true });\n      }\n    };\n  \n    // .js/ui/color.js\n    var node5 = document.querySelector(\"#color\");\n    function init3() {\n      node5.addEventListener(\"click\", onClick);\n      [...node5.querySelectorAll(\"[data-color]\")].forEach((item) => {\n        item.style.backgroundColor = item.dataset.color;\n      });\n    }\n    function onClick(e) {\n      e.preventDefault();\n      let color = e.target.dataset.color || \"\";\n      let action2 = new SetColor(currentItem, color);\n      action(action2);\n    }\n  \n    // .js/ui/text-color.js\n    var text_color_exports = {};\n    __export(text_color_exports, {\n      init: () => init4\n    });\n    var node6 = document.querySelector(\"#text-color\");\n    function init4() {\n      node6.addEventListener(\"click\", onClick2);\n      [...node6.querySelectorAll(\"[data-color]\")].forEach((item) => {\n        item.style.backgroundColor = item.dataset.color;\n      });\n    }\n    function onClick2(e) {\n      e.preventDefault();\n      let color = e.target.dataset.color || \"\";\n      let action2 = new SetTextColor(currentItem, color);\n      action(action2);\n    }\n  \n    // .js/ui/value.js\n    var value_exports = {};\n    __export(value_exports, {\n      init: () => init5,\n      update: () => update\n    });\n    var select = document.querySelector(\"#value\");\n    function init5() {\n      select.addEventListener(\"change\", onChange);\n    }\n    function update() {\n      let value = currentItem.value;\n      if (value === null) {\n        value = \"\";\n      }\n      if (typeof value == \"number\") {\n        value = \"num\";\n      }\n      select.value = value;\n    }\n    function onChange() {\n      let value = select.value;\n      if (value == \"num\") {\n        repo.get(\"value\").execute();\n      } else {\n        let action2 = new SetValue(currentItem, value || null);\n        action(action2);\n      }\n    }\n  \n    // .js/ui/layout.js\n    var layout_exports = {};\n    __export(layout_exports, {\n      init: () => init6,\n      update: () => update2\n    });\n  \n    // .js/layout/layout.js\n    var OPPOSITE = {\n      left: \"right\",\n      right: \"left\",\n      top: \"bottom\",\n      bottom: \"top\"\n    };\n    var Layout = class {\n      constructor(id, label, childDirection = \"right\") {\n        this.id = id;\n        this.label = label;\n        this.childDirection = childDirection;\n        this.SPACING_CHILD = 4;\n        repo2.set(this.id, this);\n      }\n      get option() {\n        return new Option(this.label, this.id);\n      }\n      getChildDirection(_child) {\n        return this.childDirection;\n      }\n      computeAlignment(item) {\n        let direction = item.isRoot ? this.childDirection : item.parent.resolvedLayout.getChildDirection(item);\n        if (direction == \"left\") {\n          return \"right\";\n        }\n        return \"left\";\n      }\n      pick(item, dir) {\n        if (!item.collapsed) {\n          var children = item.children;\n          for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (this.getChildDirection(child) == dir) {\n              return child;\n            }\n          }\n        }\n        if (item.isRoot) {\n          return item;\n        }\n        let childItem = item;\n        var parentLayout = childItem.parent.resolvedLayout;\n        var thisChildDirection = parentLayout.getChildDirection(item);\n        if (thisChildDirection == dir) {\n          return childItem;\n        } else if (thisChildDirection == OPPOSITE[dir]) {\n          return childItem.parent;\n        } else {\n          return parentLayout.pickSibling(childItem, dir == \"left\" || dir == \"top\" ? -1 : 1);\n        }\n      }\n      pickSibling(item, dir) {\n        if (item.isRoot) {\n          return item;\n        }\n        var children = item.parent.children;\n        var index2 = children.indexOf(item);\n        index2 += dir;\n        index2 = (index2 + children.length) % children.length;\n        return children[index2];\n      }\n      positionToggle(item, point) {\n        item.dom.toggle.setAttribute(\"transform\", `translate(${point.map(Math.round)})`);\n      }\n      getChildAnchor(item, side) {\n        let { position, contentPosition, contentSize } = item;\n        if (side == \"left\" || side == \"right\") {\n          var pos = position[0] + contentPosition[0];\n          if (side == \"left\") {\n            pos += contentSize[0];\n          }\n        } else {\n          var pos = position[1] + contentPosition[1];\n          if (side == \"top\") {\n            pos += contentSize[1];\n          }\n        }\n        return pos;\n      }\n      computeChildrenBBox(children, childIndex) {\n        let bbox = [0, 0];\n        var rankIndex = (childIndex + 1) % 2;\n        children.forEach((child) => {\n          const { size } = child;\n          bbox[rankIndex] = Math.max(bbox[rankIndex], size[rankIndex]);\n          bbox[childIndex] += size[childIndex];\n        });\n        if (children.length > 1) {\n          bbox[childIndex] += this.SPACING_CHILD * (children.length - 1);\n        }\n        return bbox;\n      }\n    };\n    var repo2 = new Map();\n  \n    // .js/layout/graph.js\n    var SPACING_RANK = 16;\n    var R = SPACING_RANK / 2;\n    var GraphLayout = class extends Layout {\n      update(item) {\n        let totalHeight = this.layoutItem(item, this.childDirection);\n        if (this.childDirection == \"left\" || this.childDirection == \"right\") {\n          this.drawLinesHorizontal(item, this.childDirection);\n        } else {\n          this.drawLinesVertical(item, this.childDirection, totalHeight);\n        }\n      }\n      layoutItem(item, rankDirection) {\n        const { contentSize, children } = item;\n        let rankIndex = rankDirection == \"left\" || rankDirection == \"right\" ? 0 : 1;\n        let childIndex = (rankIndex + 1) % 2;\n        let rankSize = contentSize[rankIndex];\n        let childSize = contentSize[childIndex];\n        if (!item.collapsed && children.length > 0) {\n          let bbox = this.computeChildrenBBox(children, childIndex);\n          rankSize += bbox[rankIndex] + SPACING_RANK;\n          childSize = Math.max(childSize, bbox[childIndex]);\n          let offset = [0, 0];\n          if (rankDirection == \"right\") {\n            offset[0] = contentSize[0] + SPACING_RANK;\n          }\n          if (rankDirection == \"bottom\") {\n            offset[1] = contentSize[1] + SPACING_RANK;\n          }\n          offset[childIndex] = Math.round((childSize - bbox[childIndex]) / 2);\n          this.layoutChildren(children, rankDirection, offset, bbox);\n        }\n        let labelPos = 0;\n        if (rankDirection == \"left\") {\n          labelPos = rankSize - contentSize[0];\n        }\n        if (rankDirection == \"top\") {\n          labelPos = rankSize - contentSize[1];\n        }\n        let contentPosition = [Math.round((childSize - contentSize[childIndex]) / 2), labelPos];\n        if (rankIndex == 0) {\n          contentPosition = contentPosition.reverse();\n        }\n        item.contentPosition = contentPosition;\n        return rankIndex == 0 ? childSize : rankSize;\n      }\n      layoutChildren(children, rankDirection, offset, bbox) {\n        var rankIndex = rankDirection == \"left\" || rankDirection == \"right\" ? 0 : 1;\n        var childIndex = (rankIndex + 1) % 2;\n        children.forEach((child) => {\n          const { size } = child;\n          if (rankDirection == \"left\") {\n            offset[0] = bbox[0] - size[0];\n          }\n          if (rankDirection == \"top\") {\n            offset[1] = bbox[1] - size[1];\n          }\n          child.position = offset;\n          offset[childIndex] += size[childIndex] + this.SPACING_CHILD;\n        });\n        return bbox;\n      }\n      drawLinesHorizontal(item, side) {\n        const { contentPosition, contentSize, resolvedShape, resolvedColor, children, dom } = item;\n        if (children.length == 0) {\n          return;\n        }\n        const dirModifier = side == \"right\" ? 1 : -1;\n        let itemAnchor = [\n          contentPosition[0] + (side == \"right\" ? contentSize[0] : 0) + dirModifier * 0.5,\n          resolvedShape.getVerticalAnchor(item)\n        ];\n        let cross = [\n          itemAnchor[0] + dirModifier * R,\n          itemAnchor[1]\n        ];\n        this.positionToggle(item, cross);\n        if (item.collapsed) {\n          return;\n        }\n        let d = [];\n        if (children.length == 1) {\n          var child = children[0];\n          const { position, resolvedShape: resolvedShape2 } = child;\n          let childAnchor = [\n            this.getChildAnchor(child, side),\n            resolvedShape2.getVerticalAnchor(child) + position[1]\n          ];\n          let midX = (itemAnchor[0] + childAnchor[0]) / 2;\n          d.push(`M ${itemAnchor}`, `C ${[midX, itemAnchor[1]]} ${[midX, childAnchor[1]]} ${childAnchor}`);\n          let path2 = node2(\"path\", { d: d.join(\" \"), stroke: resolvedColor, fill: \"none\" });\n          dom.connectors.append(path2);\n          return;\n        }\n        d.push(`M ${itemAnchor}`, `L ${cross}`);\n        const firstChild = children[0];\n        const lastChild = children[children.length - 1];\n        const cornerEndX = cross[0] + dirModifier * R;\n        const sweep = dirModifier > 0 ? 0 : 1;\n        let firstAnchor = [\n          this.getChildAnchor(firstChild, side),\n          firstChild.resolvedShape.getVerticalAnchor(firstChild) + firstChild.position[1]\n        ];\n        let lastAnchor = [\n          this.getChildAnchor(lastChild, side),\n          lastChild.resolvedShape.getVerticalAnchor(lastChild) + lastChild.position[1]\n        ];\n        d.push(`M ${firstAnchor}`, `L ${cornerEndX} ${firstAnchor[1]}`, `A ${R} ${R} 0 0 ${sweep} ${cross[0]} ${firstAnchor[1] + R}`, `L ${cross[0]} ${lastAnchor[1] - R}`, `A ${R} ${R} 0 0 ${sweep} ${cornerEndX} ${lastAnchor[1]}`, `L ${lastAnchor}`);\n        for (let i = 1; i < children.length - 1; i++) {\n          const c = children[i];\n          const y = c.resolvedShape.getVerticalAnchor(c) + c.position[1];\n          let lineStart = [cross[0], y];\n          let childAnchor = [this.getChildAnchor(c, side), y];\n          d.push(`M ${lineStart}`, `L ${childAnchor}`);\n        }\n        let path = node2(\"path\", { d: d.join(\" \"), stroke: resolvedColor, fill: \"none\" });\n        dom.connectors.append(path);\n      }\n      drawLinesVertical(item, side, totalHeight) {\n        const { contentSize, resolvedShape, resolvedColor, children, dom } = item;\n        if (children.length == 0) {\n          return;\n        }\n        const dirModifier = side == \"bottom\" ? 1 : -1;\n        let itemAnchor = [\n          resolvedShape.getHorizontalAnchor(item),\n          side == \"bottom\" ? resolvedShape.getVerticalAnchor(item) : totalHeight - contentSize[1]\n        ];\n        let cross = [\n          itemAnchor[0],\n          (side == \"bottom\" ? contentSize[1] : itemAnchor[1]) + (R * dirModifier + 0.5)\n        ];\n        this.positionToggle(item, cross);\n        if (item.collapsed) {\n          return;\n        }\n        let d = [];\n        d.push(`M ${itemAnchor}`, `L ${cross}`);\n        if (children.length == 1) {\n          let child = children[0];\n          let childAnchor = [cross[0], this.getChildAnchor(child, side)];\n          d.push(`M ${cross}`, `L ${childAnchor}`);\n          let path2 = node2(\"path\", { d: d.join(\" \"), stroke: resolvedColor, fill: \"none\" });\n          dom.connectors.append(path2);\n          return;\n        }\n        const firstChild = children[0];\n        const lastChild = children[children.length - 1];\n        const cornerEndY = cross[1] + dirModifier * R;\n        const sweep = dirModifier > 0 ? 1 : 0;\n        let firstAnchor = [\n          firstChild.resolvedShape.getHorizontalAnchor(firstChild) + firstChild.position[0],\n          this.getChildAnchor(firstChild, side)\n        ];\n        let lastAnchor = [\n          lastChild.resolvedShape.getHorizontalAnchor(lastChild) + lastChild.position[0],\n          this.getChildAnchor(lastChild, side)\n        ];\n        d.push(`M ${firstAnchor}`, `L ${firstAnchor[0]} ${cornerEndY}`, `A ${R} ${R} 0 0 ${sweep} ${firstAnchor[0] + R} ${cross[1]}`, `L ${lastAnchor[0] - R} ${cross[1]}`, `A ${R} ${R} 0 0 ${sweep} ${lastAnchor[0]} ${cornerEndY}`, `L ${lastAnchor}`);\n        for (var i = 1; i < children.length - 1; i++) {\n          const c = children[i];\n          const x = c.resolvedShape.getHorizontalAnchor(c) + c.position[0];\n          let lineStart = [x, cross[1]];\n          let childAnchor = [x, this.getChildAnchor(c, side)];\n          d.push(`M ${lineStart}`, `L ${childAnchor}`);\n        }\n        let path = node2(\"path\", { d: d.join(\" \"), stroke: resolvedColor, fill: \"none\" });\n        dom.connectors.append(path);\n      }\n    };\n    new GraphLayout(\"graph-bottom\", \"Bottom\", \"bottom\");\n    new GraphLayout(\"graph-top\", \"Top\", \"top\");\n    new GraphLayout(\"graph-left\", \"Left\", \"left\");\n    new GraphLayout(\"graph-right\", \"Right\", \"right\");\n  \n    // .js/layout/tree.js\n    var SPACING_RANK2 = 32;\n    var R2 = SPACING_RANK2 / 4;\n    var LINE_OFFSET = SPACING_RANK2 / 2;\n    var TreeLayout = class extends Layout {\n      update(item) {\n        let totalWidth = this.layoutItem(item, this.childDirection);\n        this.drawLines(item, this.childDirection, totalWidth);\n      }\n      layoutItem(item, rankDirection) {\n        const { contentSize, children } = item;\n        let rankSize = contentSize[0];\n        if (!item.collapsed && children.length > 0) {\n          let bbox = this.computeChildrenBBox(children, 1);\n          rankSize = Math.max(rankSize, bbox[0] + SPACING_RANK2);\n          let offset = [SPACING_RANK2, contentSize[1] + this.SPACING_CHILD];\n          if (rankDirection == \"left\") {\n            offset[0] = rankSize - bbox[0] - SPACING_RANK2;\n          }\n          this.layoutChildren(children, rankDirection, offset, bbox);\n        }\n        let labelPos = 0;\n        if (rankDirection == \"left\") {\n          labelPos = rankSize - contentSize[0];\n        }\n        item.contentPosition = [labelPos, 0];\n        return rankSize;\n      }\n      layoutChildren(children, rankDirection, offset, bbox) {\n        children.forEach((child) => {\n          const { size } = child;\n          let left = offset[0];\n          if (rankDirection == \"left\") {\n            left += bbox[0] - size[0];\n          }\n          child.position = [left, offset[1]];\n          offset[1] += size[1] + this.SPACING_CHILD;\n        });\n      }\n      drawLines(item, direction, totalWidth) {\n        const { resolvedShape, resolvedColor, children, dom } = item;\n        const dirModifier = direction == \"right\" ? 1 : -1;\n        const lineX = (direction == \"left\" ? totalWidth - LINE_OFFSET : LINE_OFFSET) + 0.5;\n        const toggleDistance = TOGGLE_SIZE + 2;\n        let pointAnchor = [\n          lineX,\n          resolvedShape.getVerticalAnchor(item)\n        ];\n        this.positionToggle(item, [pointAnchor[0], pointAnchor[1] + toggleDistance]);\n        if (children.length == 0 || item.collapsed) {\n          return;\n        }\n        let lastChild = children[children.length - 1];\n        let lineEnd = [\n          lineX,\n          lastChild.resolvedShape.getVerticalAnchor(lastChild) + lastChild.position[1] - R2\n        ];\n        let d = [`M ${pointAnchor}`, `L ${lineEnd}`];\n        let sweep = dirModifier > 0 ? 0 : 1;\n        children.forEach((child) => {\n          const { resolvedShape: resolvedShape2, position } = child;\n          const y = resolvedShape2.getVerticalAnchor(child) + position[1];\n          d.push(`M ${lineX} ${y - R2}`, `A ${R2} ${R2} 0 0 ${sweep} ${lineX + dirModifier * R2} ${y}`, `L ${this.getChildAnchor(child, direction)} ${y}`);\n        });\n        let path = node2(\"path\", { d: d.join(\" \"), stroke: resolvedColor, fill: \"none\" });\n        dom.connectors.append(path);\n      }\n    };\n    new TreeLayout(\"tree-left\", \"Left\", \"left\");\n    new TreeLayout(\"tree-right\", \"Right\", \"right\");\n  \n    // .js/layout/map.js\n    var MapLayout = class extends GraphLayout {\n      constructor() {\n        super(...arguments);\n        this.LINE_THICKNESS = 8;\n      }\n      update(item) {\n        if (item.isRoot) {\n          this.layoutRoot(item);\n        } else {\n          var side = this.getChildDirection(item);\n          repo2.get(`graph-${side}`).update(item);\n        }\n      }\n      getChildDirection(child) {\n        while (!child.parent.isRoot) {\n          child = child.parent;\n        }\n        let side = child.side;\n        if (side) {\n          return side;\n        }\n        let counts = { left: 0, right: 0 };\n        child.parent.children.forEach((sibling) => {\n          let side2 = sibling.side;\n          if (!side2) {\n            side2 = counts.right > counts.left ? \"left\" : \"right\";\n            sibling.side = side2;\n          }\n          counts[side2]++;\n        });\n        return child.side;\n      }\n      pickSibling(item, dir) {\n        if (item.isRoot) {\n          return item;\n        }\n        const parent = item.parent;\n        var children = parent.children;\n        if (parent.isRoot) {\n          var side = this.getChildDirection(item);\n          children = children.filter((child) => this.getChildDirection(child) == side);\n        }\n        var index2 = children.indexOf(item);\n        index2 += dir;\n        index2 = (index2 + children.length) % children.length;\n        return children[index2];\n      }\n      layoutRoot(item) {\n        const { children, contentSize } = item;\n        let childrenLeft = [];\n        let childrenRight = [];\n        let contentPosition = [0, 0];\n        children.forEach((child) => {\n          var side = this.getChildDirection(child);\n          if (side == \"left\") {\n            childrenLeft.push(child);\n          } else {\n            childrenRight.push(child);\n          }\n        });\n        let bboxLeft = this.computeChildrenBBox(childrenLeft, 1);\n        let bboxRight = this.computeChildrenBBox(childrenRight, 1);\n        let height = Math.max(bboxLeft[1], bboxRight[1], contentSize[1]);\n        let left = 0;\n        this.layoutChildren(childrenLeft, \"left\", [left, Math.round((height - bboxLeft[1]) / 2)], bboxLeft);\n        left += bboxLeft[0];\n        if (childrenLeft.length) {\n          left += SPACING_RANK;\n        }\n        contentPosition[0] = left;\n        left += contentSize[0];\n        if (childrenRight.length) {\n          left += SPACING_RANK;\n        }\n        this.layoutChildren(childrenRight, \"right\", [left, Math.round((height - bboxRight[1]) / 2)], bboxRight);\n        left += bboxRight[0];\n        contentPosition[1] = Math.round((height - contentSize[1]) / 2);\n        item.contentPosition = contentPosition;\n        this.drawRootConnectors(item, \"left\", childrenLeft);\n        this.drawRootConnectors(item, \"right\", childrenRight);\n      }\n      drawRootConnectors(item, direction, children) {\n        if (children.length == 0 || item.collapsed) {\n          return;\n        }\n        const { contentSize, contentPosition, resolvedShape, dom } = item;\n        let x1 = contentPosition[0] + contentSize[0] / 2;\n        let y1 = resolvedShape.getVerticalAnchor(item);\n        const half = this.LINE_THICKNESS / 2;\n        let paths = children.map((child) => {\n          const { resolvedColor, resolvedShape: resolvedShape2, position } = child;\n          let x2 = this.getChildAnchor(child, direction);\n          let y2 = resolvedShape2.getVerticalAnchor(child) + position[1];\n          let angle = Math.atan2(y2 - y1, x2 - x1) + Math.PI / 2;\n          let dx = Math.cos(angle) * half;\n          let dy = Math.sin(angle) * half;\n          let d = [\n            `M ${x1 - dx} ${y1 - dy}`,\n            `Q ${(x2 + x1) / 2} ${y2} ${x2} ${y2}`,\n            `Q ${(x2 + x1) / 2} ${y2} ${x1 + dx} ${y1 + dy}`,\n            `Z`\n          ];\n          let attrs = {\n            d: d.join(\" \"),\n            fill: resolvedColor,\n            stroke: resolvedColor\n          };\n          return node2(\"path\", attrs);\n        });\n        dom.connectors.append(...paths);\n      }\n    };\n    new MapLayout(\"map\", \"Map\");\n  \n    // .js/ui/layout.js\n    var select2 = document.querySelector(\"#layout\");\n    function init6() {\n      let layout = repo2.get(\"map\");\n      select2.append(layout.option);\n      let label = buildGroup(\"Graph\");\n      let graphOptions = [\"right\", \"left\", \"bottom\", \"top\"].map((name) => {\n        return repo2.get(`graph-${name}`).option;\n      });\n      label.append(...graphOptions);\n      label = buildGroup(\"Tree\");\n      let treeOptions = [\"right\", \"left\"].map((name) => {\n        return repo2.get(`tree-${name}`).option;\n      });\n      label.append(...treeOptions);\n      select2.addEventListener(\"change\", onChange2);\n    }\n    function update2() {\n      var value = \"\";\n      var layout = currentItem.layout;\n      if (layout) {\n        value = layout.id;\n      }\n      select2.value = value;\n      getOption(\"\").disabled = currentItem.isRoot;\n      getOption(\"map\").disabled = !currentItem.isRoot;\n    }\n    function onChange2() {\n      let layout = repo2.get(select2.value);\n      var action2 = new SetLayout(currentItem, layout);\n      action(action2);\n    }\n    function getOption(value) {\n      return select2.querySelector(`option[value=\"${value}\"]`);\n    }\n    function buildGroup(label) {\n      let node11 = document.createElement(\"optgroup\");\n      node11.label = label;\n      select2.append(node11);\n      return node11;\n    }\n  \n    // .js/ui/icon.js\n    var icon_exports = {};\n    __export(icon_exports, {\n      init: () => init7,\n      update: () => update3\n    });\n    var select3 = document.querySelector(\"#icons\");\n    function init7() {\n      select3.addEventListener(\"change\", onChange3);\n    }\n    function update3() {\n      select3.value = currentItem.icon || \"\";\n    }\n    function onChange3() {\n      let action2 = new SetIcon(currentItem, select3.value);\n      action(action2);\n    }\n  \n    // .js/ui/shape.js\n    var shape_exports = {};\n    __export(shape_exports, {\n      init: () => init8,\n      update: () => update4\n    });\n  \n    // .js/shape/shape.js\n    var VERTICAL_OFFSET = 0.5;\n    var Shape = class {\n      constructor(id, label) {\n        this.id = id;\n        this.label = label;\n        repo3.set(this.id, this);\n      }\n      get option() {\n        return new Option(this.label, this.id);\n      }\n      update(item) {\n        item.dom.content.style.borderColor = item.resolvedColor;\n      }\n      getHorizontalAnchor(item) {\n        const { contentPosition, contentSize } = item;\n        return Math.round(contentPosition[0] + contentSize[0] / 2) + 0.5;\n      }\n      getVerticalAnchor(item) {\n        const { contentPosition, contentSize } = item;\n        return contentPosition[1] + Math.round(contentSize[1] * VERTICAL_OFFSET) + 0.5;\n      }\n    };\n    var repo3 = new Map();\n  \n    // .js/shape/box.js\n    var Box = class extends Shape {\n      constructor() {\n        super(\"box\", \"Box\");\n      }\n    };\n    new Box();\n  \n    // .js/shape/ellipse.js\n    var Ellipse = class extends Shape {\n      constructor() {\n        super(\"ellipse\", \"Ellipse\");\n      }\n    };\n    new Ellipse();\n  \n    // .js/shape/underline.js\n    var VERTICAL_OFFSET2 = -4;\n    var Underline = class extends Shape {\n      constructor() {\n        super(\"underline\", \"Underline\");\n      }\n      update(item) {\n        const { contentPosition, resolvedColor, contentSize, dom } = item;\n        let left = contentPosition[0];\n        let right = left + contentSize[0];\n        let top = this.getVerticalAnchor(item);\n        let d = [\n          `M ${left} ${top}`,\n          `L ${right} ${top}`\n        ];\n        let path = node2(\"path\", { d: d.join(\" \"), stroke: resolvedColor, fill: \"none\" });\n        dom.connectors.append(path);\n      }\n      getVerticalAnchor(item) {\n        const { contentPosition, contentSize } = item;\n        return contentPosition[1] + contentSize[1] + VERTICAL_OFFSET2 + 0.5;\n      }\n    };\n    new Underline();\n  \n    // .js/ui/shape.js\n    var select4 = document.querySelector(\"#shape\");\n    function init8() {\n      repo3.forEach((shape) => select4.append(shape.option));\n      select4.addEventListener(\"change\", onChange4);\n    }\n    function update4() {\n      let value = \"\";\n      let shape = currentItem.shape;\n      if (shape) {\n        value = shape.id;\n      }\n      select4.value = value;\n    }\n    function onChange4() {\n      let shape = repo3.get(select4.value);\n      let action2 = new SetShape(currentItem, shape);\n      action(action2);\n    }\n  \n    // .js/ui/status.js\n    var status_exports = {};\n    __export(status_exports, {\n      init: () => init9,\n      update: () => update5\n    });\n    var select5 = document.querySelector(\"#status\");\n    var STATUS_MAP = {\n      \"yes\": true,\n      \"no\": false,\n      \"\": null\n    };\n    function statusToString(status) {\n      for (let key in STATUS_MAP) {\n        if (STATUS_MAP[key] === status) {\n          return key;\n        }\n      }\n      return String(status);\n    }\n    function stringToStatus(str) {\n      return str in STATUS_MAP ? STATUS_MAP[str] : str;\n    }\n    function init9() {\n      select5.addEventListener(\"change\", onChange5);\n    }\n    function update5() {\n      select5.value = statusToString(currentItem.status);\n    }\n    function onChange5() {\n      let status = stringToStatus(select5.value);\n      let action2 = new SetStatus(currentItem, status);\n      action(action2);\n    }\n  \n    // .js/ui/tip.js\n    var tip_exports = {};\n    __export(tip_exports, {\n      init: () => init10\n    });\n    var node7 = document.querySelector(\"#tip\");\n    function init10() {\n      node7.addEventListener(\"click\", hide);\n      subscribe(\"command-child\", hide);\n      subscribe(\"command-sibling\", hide);\n    }\n    function hide() {\n      unsubscribe(\"command-child\", hide);\n      unsubscribe(\"command-sibling\", hide);\n      node7.removeEventListener(\"click\", hide);\n      node7.hidden = true;\n    }\n  \n    // .js/ui/io.js\n    var io_exports = {};\n    __export(io_exports, {\n      hide: () => hide2,\n      init: () => init11,\n      isActive: () => isActive,\n      quickSave: () => quickSave,\n      restore: () => restore,\n      show: () => show\n    });\n  \n    // .js/ui/backend/backend.js\n    var BackendUI = class {\n      constructor(backend, label) {\n        this.backend = backend;\n        this.label = label;\n        this.mode = \"load\";\n        repo4.set(this.id, this);\n        this.prefix = `mm.app.${this.id}`;\n        const { go, cancel } = this;\n        cancel.addEventListener(\"click\", (_) => hide2());\n        go.addEventListener(\"click\", (_) => this.submit());\n      }\n      get id() {\n        return this.backend.id;\n      }\n      get node() {\n        return document.querySelector(`#${this.id}`);\n      }\n      get cancel() {\n        return this.node.querySelector(\".cancel\");\n      }\n      get go() {\n        return this.node.querySelector(\".go\");\n      }\n      get option() {\n        return new Option(this.label, this.id);\n      }\n      reset() {\n        this.backend.reset();\n      }\n      setState(_data) {\n      }\n      getState() {\n        return {};\n      }\n      show(mode2) {\n        this.mode = mode2;\n        const { go, node: node11 } = this;\n        go.textContent = mode2.charAt(0).toUpperCase() + mode2.substring(1);\n        [...node11.querySelectorAll(\"[data-for]\")].forEach((node12) => node12.hidden = true);\n        [...node11.querySelectorAll(`[data-for~=${mode2}]`)].forEach((node12) => node12.hidden = false);\n        go.focus();\n      }\n      saveDone() {\n        setThrobber(false);\n        publish(\"save-done\", this);\n      }\n      loadDone(json) {\n        setThrobber(false);\n        try {\n          showMap(Map2.fromJSON(json));\n          publish(\"load-done\", this);\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      error(e) {\n        setThrobber(false);\n        let message = e instanceof Error ? e.message : e;\n        alert(`IO error: ${message}`);\n      }\n      submit() {\n        switch (this.mode) {\n          case \"save\":\n            this.save();\n            break;\n          case \"load\":\n            this.load();\n            break;\n        }\n      }\n    };\n    var repo4 = new Map();\n    function buildList(list, select7) {\n      let data = [];\n      for (let id in list) {\n        data.push({ id, name: list[id] });\n      }\n      data.sort((a, b) => a.name.localeCompare(b.name));\n      let options = data.map((item) => new Option(item.name, item.id));\n      select7.append(...options);\n    }\n  \n    // .js/backend/backend.js\n    var Backend = class {\n      constructor(id) {\n        this.id = id;\n        repo5.set(id, this);\n      }\n      reset() {\n      }\n    };\n    var repo5 = new Map();\n  \n    // .js/backend/local.js\n    var Local = class extends Backend {\n      constructor() {\n        super(\"local\");\n        this.prefix = \"mm.map\";\n      }\n      save(data, id, name) {\n        localStorage.setItem(`${this.prefix}.${id}`, data);\n        let names = this.list();\n        names[id] = name;\n        localStorage.setItem(`${this.prefix}.names`, JSON.stringify(names));\n      }\n      load(id) {\n        let data = localStorage.getItem(`${this.prefix}.${id}`);\n        if (!data) {\n          throw new Error(\"There is no such saved map\");\n        }\n        return data;\n      }\n      remove(id) {\n        localStorage.removeItem(`${this.prefix}.${id}`);\n        let names = this.list();\n        delete names[id];\n        localStorage.setItem(`${this.prefix}.names`, JSON.stringify(names));\n      }\n      list() {\n        try {\n          let data = localStorage.getItem(`${this.prefix}.names`) || \"{}\";\n          return JSON.parse(data);\n        } catch (e) {\n          return {};\n        }\n      }\n    };\n  \n    // .js/format/format.js\n    var Format = class {\n      constructor(id, label) {\n        this.id = id;\n        this.label = label;\n        repo6.set(id, this);\n      }\n      get option() {\n        return new Option(this.label, this.id);\n      }\n    };\n    var repo6 = new Map();\n    function getByProperty(property, value) {\n      let filtered = [...repo6.values()].filter((format) => format[property] == value);\n      return filtered[0] || null;\n    }\n    function getByName(name) {\n      let index2 = name.lastIndexOf(\".\");\n      if (index2 == -1) {\n        return null;\n      }\n      let extension = name.substring(index2 + 1).toLowerCase();\n      return getByProperty(\"extension\", extension);\n    }\n    function getByMime(mime) {\n      return getByProperty(\"mime\", mime);\n    }\n    function nl2br(str) {\n      return str.replace(/\\n/g, \"<br/>\");\n    }\n    function br2nl(str) {\n      return str.replace(/<br\\s*\\/?>/g, \"\\n\");\n    }\n  \n    // .js/ui/backend/local.js\n    var LocalUI = class extends BackendUI {\n      constructor() {\n        super(new Local(), \"Browser storage\");\n        this.remove.addEventListener(\"click\", (_) => {\n          var id = this.list.value;\n          if (!id) {\n            return;\n          }\n          this.backend.remove(id);\n          this.show(this.mode);\n        });\n      }\n      get list() {\n        return this.node.querySelector(\".list\");\n      }\n      get remove() {\n        return this.node.querySelector(\".remove\");\n      }\n      show(mode2) {\n        super.show(mode2);\n        const { go, remove, list } = this;\n        go.disabled = false;\n        if (mode2 == \"load\") {\n          let stored = this.backend.list();\n          list.innerHTML = \"\";\n          if (Object.keys(stored).length) {\n            go.disabled = false;\n            remove.disabled = false;\n            buildList(stored, this.list);\n          } else {\n            this.go.disabled = true;\n            this.remove.disabled = true;\n            let o = document.createElement(\"option\");\n            o.innerHTML = \"(no maps saved)\";\n            this.list.append(o);\n          }\n        }\n      }\n      setState(data) {\n        this.load(data.id);\n      }\n      getState() {\n        let data = {\n          b: this.id,\n          id: currentMap.id\n        };\n        return data;\n      }\n      save() {\n        let json = currentMap.toJSON();\n        let data = repo6.get(\"native\").to(json);\n        try {\n          this.backend.save(data, currentMap.id, currentMap.name);\n          this.saveDone();\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      load(id = this.list.value) {\n        try {\n          let data = this.backend.load(id);\n          var json = repo6.get(\"native\").from(data);\n          this.loadDone(json);\n        } catch (e) {\n          this.error(e);\n        }\n      }\n    };\n  \n    // .js/backend/file.js\n    var File = class extends Backend {\n      constructor() {\n        super(\"file\");\n        this.input = document.createElement(\"input\");\n      }\n      save(data, name) {\n        let link = document.createElement(\"a\");\n        link.download = name;\n        link.href = \"data:text/plain;base64,\" + btoa(unescape(encodeURIComponent(data)));\n        document.body.append(link);\n        link.click();\n        link.remove();\n      }\n      load() {\n        const { input } = this;\n        input.type = \"file\";\n        return new Promise((resolve, reject) => {\n          input.onchange = (_) => {\n            let file = input.files[0];\n            if (!file) {\n              return;\n            }\n            var reader = new FileReader();\n            reader.onload = function() {\n              resolve({ data: reader.result, name: file.name });\n            };\n            reader.onerror = function() {\n              reject(reader.error);\n            };\n            reader.readAsText(file);\n          };\n          input.click();\n        });\n      }\n    };\n  \n    // .js/format/native.js\n    var Native = class extends Format {\n      constructor() {\n        super(\"native\", \"Native (JSON)\");\n        this.extension = \"mymind\";\n        this.mime = \"application/vnd.mymind+json\";\n      }\n      to(data) {\n        return JSON.stringify(data, null, \"\t\") + \"\\n\";\n      }\n      from(data) {\n        return JSON.parse(data);\n      }\n    };\n  \n    // .js/format/freemind.js\n    var Native2 = class extends Format {\n      constructor(id = \"freemind\", label = \"FreeMind\") {\n        super(id, label);\n        this.extension = \"mm\";\n        this.mime = \"application/x-freemind\";\n      }\n      to(data) {\n        var doc = document.implementation.createDocument(null, null, null);\n        var map = doc.createElement(\"map\");\n        map.setAttribute(\"version\", \"1.0.1\");\n        map.appendChild(this.serializeItem(doc, data.root));\n        doc.appendChild(map);\n        var serializer = new XMLSerializer();\n        return serializer.serializeToString(doc);\n      }\n      from(data) {\n        var parser = new DOMParser();\n        var doc = parser.parseFromString(data, \"application/xml\");\n        if (doc.documentElement.nodeName.toLowerCase() == \"parsererror\") {\n          throw new Error(doc.documentElement.textContent || \"\");\n        }\n        var root = doc.documentElement.getElementsByTagName(\"node\")[0];\n        if (!root) {\n          throw new Error(\"No root node found\");\n        }\n        var json = {\n          root: this.parseNode(root, { shape: \"underline\" })\n        };\n        json.root.layout = \"map\";\n        json.root.shape = \"ellipse\";\n        return json;\n      }\n      serializeItem(doc, json) {\n        var elm = this.serializeAttributes(doc, json);\n        (json.children || []).forEach((child) => {\n          elm.appendChild(this.serializeItem(doc, child));\n        });\n        return elm;\n      }\n      serializeAttributes(doc, json) {\n        var elm = doc.createElement(\"node\");\n        elm.setAttribute(\"TEXT\", br2nl(json.text));\n        json.id && elm.setAttribute(\"ID\", json.id);\n        if (json.side) {\n          elm.setAttribute(\"POSITION\", json.side);\n        }\n        if (json.shape == \"box\") {\n          elm.setAttribute(\"STYLE\", \"bubble\");\n        }\n        if (json.collapsed) {\n          elm.setAttribute(\"FOLDED\", \"true\");\n        }\n        if (json.notes) {\n          var notesElm = doc.createElement(\"richcontent\");\n          notesElm.setAttribute(\"TYPE\", \"NOTE\");\n          notesElm.appendChild(doc.createCDATASection(\"<html><head></head><body>\" + json.notes + \"</body></html>\"));\n          elm.appendChild(notesElm);\n        }\n        return elm;\n      }\n      parseNode(node11, parent) {\n        var json = this.parseAttributes(node11, parent);\n        for (var i = 0; i < node11.childNodes.length; i++) {\n          var child = node11.childNodes[i];\n          if (child instanceof Element && child.nodeName.toLowerCase() == \"node\") {\n            json.children.push(this.parseNode(child, json));\n          }\n        }\n        return json;\n      }\n      parseAttributes(node11, parent) {\n        var json = {\n          children: [],\n          text: nl2br(node11.getAttribute(\"TEXT\") || \"\"),\n          id: node11.getAttribute(\"ID\")\n        };\n        var position = node11.getAttribute(\"POSITION\");\n        if (position) {\n          json.side = position;\n        }\n        var style = node11.getAttribute(\"STYLE\");\n        if (style == \"bubble\") {\n          json.shape = \"box\";\n        } else {\n          json.shape = parent.shape;\n        }\n        if (node11.getAttribute(\"FOLDED\") == \"true\") {\n          json.collapsed = 1;\n        }\n        var children = node11.children;\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          switch (child.nodeName.toLowerCase()) {\n            case \"richcontent\":\n              if (child.getAttribute(\"TYPE\") == \"NOTE\") {\n                var body = child.querySelector(\"body > *\");\n                if (body) {\n                  var serializer = new XMLSerializer();\n                  json.notes = serializer.serializeToString(body).trim();\n                }\n              }\n              break;\n            case \"font\":\n              if (child.getAttribute(\"ITALIC\") == \"true\") {\n                json.text = \"<i>\" + json.text + \"</i>\";\n              }\n              if (child.getAttribute(\"BOLD\") == \"true\") {\n                json.text = \"<b>\" + json.text + \"</b>\";\n              }\n              break;\n          }\n        }\n        return json;\n      }\n    };\n  \n    // .js/format/mma.js\n    var MMA = class extends Native2 {\n      constructor() {\n        super(\"mma\", \"Mind Map Architect\");\n        this.extension = \"mma\";\n        this.serializeAttributes = function(doc, json) {\n          var elm = doc.createElement(\"node\");\n          elm.setAttribute(\"title\", br2nl(json.text));\n          elm.setAttribute(\"expand\", json.collapsed ? \"false\" : \"true\");\n          if (json.side) {\n            elm.setAttribute(\"direction\", json.side == \"left\" ? \"0\" : \"1\");\n          }\n          if (json.color) {\n            var parts = json.color.match(/^#(.)(.)(.)$/);\n            var r = new Array(5).join(parts[1]);\n            var g = new Array(5).join(parts[2]);\n            var b = new Array(5).join(parts[3]);\n            elm.setAttribute(\"color\", \"#\" + [r, g, b].join(\"\"));\n          }\n          if (json.icon) {\n            elm.setAttribute(\"icon\", json.icon);\n          }\n          return elm;\n        };\n      }\n      parseAttributes(node11, parent) {\n        var json = {\n          children: [],\n          text: nl2br(node11.getAttribute(\"title\") || \"\"),\n          shape: \"box\"\n        };\n        if (node11.getAttribute(\"expand\") == \"false\") {\n          json.collapsed = 1;\n        }\n        var direction = node11.getAttribute(\"direction\");\n        if (direction == \"0\") {\n          json.side = \"left\";\n        }\n        if (direction == \"1\") {\n          json.side = \"right\";\n        }\n        var color = node11.getAttribute(\"color\");\n        if (color) {\n          var re = color.match(/^#(....)(....)(....)$/);\n          if (re) {\n            let parts = re.slice(1).map((str) => parseInt(str, 16) >> 8).map((num) => Math.round(num / 17)).map((num) => num.toString(16));\n            json.color = \"#\" + parts.join(\"\");\n          }\n        }\n        json.icon = node11.getAttribute(\"icon\") || \"\";\n        return json;\n      }\n    };\n  \n    // .js/format/mup.js\n    var Native3 = class extends Format {\n      constructor() {\n        super(\"mup\", \"MindMup\");\n        this.extension = \"mup\";\n      }\n      to(data) {\n        var root = MMtoMup(data.root);\n        return JSON.stringify(root, null, 2);\n      }\n      from(data) {\n        var source = JSON.parse(data);\n        var root = MupToMM(source);\n        root.layout = \"map\";\n        return { root };\n      }\n    };\n    function MupToMM(item) {\n      var json = {\n        text: nl2br(item.title),\n        id: item.id,\n        shape: \"box\",\n        icon: item.icon\n      };\n      if (item.attr && item.attr.style && item.attr.style.background) {\n        json.color = item.attr.style.background;\n      }\n      if (item.attr && item.attr.collapsed) {\n        json.collapsed = 1;\n      }\n      if (item.ideas) {\n        var data = [];\n        for (var key in item.ideas) {\n          var child = MupToMM(item.ideas[key]);\n          var num = parseFloat(key);\n          child.side = num < 0 ? \"left\" : \"right\";\n          data.push({\n            child,\n            num\n          });\n        }\n        data.sort(function(a, b) {\n          return a.num - b.num;\n        });\n        json.children = data.map((item2) => item2.child);\n      }\n      return json;\n    }\n    function MMtoMup(item, side) {\n      var result = {\n        id: item.id,\n        title: br2nl(item.text),\n        icon: item.icon,\n        attr: {}\n      };\n      if (item.color) {\n        result.attr.style = { background: item.color };\n      }\n      if (item.collapsed) {\n        result.attr.collapsed = true;\n      }\n      if (item.children) {\n        result.ideas = {};\n        for (var i = 0; i < item.children.length; i++) {\n          var child = item.children[i];\n          var childSide = side || child.side;\n          var key = i + 1;\n          if (childSide == \"left\") {\n            key *= -1;\n          }\n          result.ideas[key] = MMtoMup(child, childSide);\n        }\n      }\n      return result;\n    }\n  \n    // .js/format/plaintext.js\n    var Plaintext = class extends Format {\n      constructor() {\n        super(\"plaintext\", \"Plain text\");\n        this.extension = \"txt\";\n        this.mime = \"application/vnd.mymind+txt\";\n      }\n      to(data) {\n        return serializeItem(\"root\" in data ? data.root : data);\n      }\n      from(data) {\n        var lines = data.split(\"\\n\").filter(function(line) {\n          return line.match(/\\S/);\n        });\n        var items = parseItems(lines);\n        let result;\n        if (items.length == 1) {\n          result = {\n            root: items[0]\n          };\n        } else {\n          result = {\n            root: {\n              text: \"\",\n              children: items\n            }\n          };\n        }\n        result.root.layout = \"map\";\n        return result;\n      }\n    };\n    function serializeItem(item, depth = 0) {\n      var lines = (item.children || []).map((child) => {\n        return serializeItem(child, depth + 1);\n      });\n      var prefix = new Array(depth + 1).join(\"\t\");\n      lines.unshift(prefix + item.text.replace(/\\n/g, \"\"));\n      return lines.join(\"\\n\") + (depth ? \"\" : \"\\n\");\n    }\n    function parseItems(lines) {\n      let items = [];\n      if (!lines.length) {\n        return items;\n      }\n      var firstPrefix = parsePrefix(lines[0]);\n      let currentItem2 = null;\n      let childLines = [];\n      var convertChildLinesToChildren = function() {\n        if (!currentItem2 || !childLines.length) {\n          return;\n        }\n        var children = parseItems(childLines);\n        if (children.length) {\n          currentItem2.children = children;\n        }\n        childLines = [];\n      };\n      lines.forEach((line) => {\n        if (parsePrefix(line) == firstPrefix) {\n          convertChildLinesToChildren();\n          currentItem2 = { text: line.match(/^\\s*(.*)/)[1] };\n          items.push(currentItem2);\n        } else {\n          childLines.push(line);\n        }\n      });\n      convertChildLinesToChildren();\n      return items;\n    }\n    function parsePrefix(line) {\n      return line.match(/^\\s*/)[0];\n    }\n  \n    // .js/ui/format-select.js\n    var all = [Native, Native2, MMA, Native3, Plaintext].map((ctor) => new ctor());\n    function fill(select7) {\n      let nodes = all.map((bui) => bui.option);\n      select7.append(...nodes);\n    }\n  \n    // .js/ui/backend/file.js\n    var FileUI = class extends BackendUI {\n      constructor() {\n        super(new File(), \"File\");\n        fill(this.format);\n        this.format.value = localStorage.getItem(this.prefix + \"format\") || \"native\";\n      }\n      get format() {\n        return this.node.querySelector(\".format\");\n      }\n      show(mode2) {\n        super.show(mode2);\n        this.go.textContent = mode2 == \"save\" ? \"Save\" : \"Browse\";\n      }\n      save() {\n        let format = repo6.get(this.format.value);\n        var json = currentMap.toJSON();\n        var data = format.to(json);\n        var name = currentMap.name + \".\" + format.extension;\n        try {\n          this.backend.save(data, name);\n          this.saveDone();\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      async load() {\n        try {\n          let data = await this.backend.load();\n          let format = getByName(data.name) || repo6.get(\"native\");\n          let json = format.from(data.data);\n          this.loadDone(json);\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      submit() {\n        localStorage.setItem(`${this.prefix}.format`, this.format.value);\n        super.submit();\n      }\n    };\n  \n    // .js/backend/webdav.js\n    var WebDAV = class extends Backend {\n      constructor() {\n        super(\"webdav\");\n      }\n      save(data, url) {\n        return this.request(\"PUT\", url, data);\n      }\n      load(url) {\n        return this.request(\"GET\", url);\n      }\n      async request(method, url, data) {\n        let init20 = {\n          method,\n          credentials: \"include\"\n        };\n        if (data) {\n          init20.body = data;\n        }\n        let response = await fetch(url, init20);\n        let text = await response.text();\n        if (response.ok) {\n          return text;\n        } else {\n          throw new Error(`HTTP/${response.status}\n  \n  ${text}`);\n        }\n      }\n    };\n  \n    // .js/ui/backend/webdav.js\n    var WebDAVUI = class extends BackendUI {\n      constructor() {\n        super(new WebDAV(), \"Generic WebDAV\");\n        this.current = \"\";\n        this.url.value = localStorage.getItem(`${this.prefix}.url`) || \"\";\n      }\n      get url() {\n        return this.node.querySelector(\".url\");\n      }\n      getState() {\n        let data = { url: this.current };\n        return data;\n      }\n      setState(data) {\n        this.load(data.url);\n      }\n      async save() {\n        setThrobber(true);\n        var map = currentMap;\n        var url = this.url.value;\n        localStorage.setItem(`${this.prefix}.url`, url);\n        if (url.match(/\\.mymind$/)) {\n        } else {\n          if (url.charAt(url.length - 1) != \"/\") {\n            url += \"/\";\n          }\n          url += `${map.name}.${repo6.get(\"native\").extension}`;\n        }\n        this.current = url;\n        let json = map.toJSON();\n        let data = repo6.get(\"native\").to(json);\n        try {\n          await this.backend.save(data, url);\n          this.saveDone();\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      async load(url = this.url.value) {\n        this.current = url;\n        setThrobber(true);\n        var lastIndex = url.lastIndexOf(\"/\");\n        this.url.value = url.substring(0, lastIndex);\n        localStorage.setItem(`${this.prefix}.url`, this.url.value);\n        try {\n          let data = await this.backend.load(url);\n          let json = repo6.get(\"native\").from(data);\n          this.loadDone(json);\n        } catch (e) {\n          this.error(e);\n        }\n      }\n    };\n  \n    // .js/backend/image.js\n    var ImageBackend = class extends Backend {\n      constructor() {\n        super(\"image\");\n      }\n      async save(format) {\n        const serializer = new XMLSerializer();\n        const encoder = new TextEncoder();\n        let xmlStr = serializer.serializeToString(currentMap.node);\n        let encoded = encoder.encode(xmlStr);\n        let byteString = [...encoded].map((byte) => String.fromCharCode(byte)).join(\"\");\n        let base64 = btoa(byteString);\n        let svgUrl = `data:image/svg+xml;base64,${base64}`;\n        switch (format) {\n          case \"svg\":\n            return svgUrl;\n          case \"png\":\n            let img = await waitForImageLoad(svgUrl);\n            let canvas = document.createElement(\"canvas\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            canvas.getContext(\"2d\").drawImage(img, 0, 0);\n            return new Promise((resolve) => {\n              canvas.toBlob((blob) => resolve(URL.createObjectURL(blob)), \"image/png\");\n            });\n            break;\n        }\n      }\n      download(href) {\n        let link = document.createElement(\"a\");\n        link.download = currentMap.name;\n        link.href = href;\n        link.click();\n      }\n    };\n    async function waitForImageLoad(src) {\n      let img = new Image();\n      img.src = src;\n      return new Promise((resolve) => {\n        img.onload = () => resolve(img);\n      });\n    }\n  \n    // .js/ui/backend/image.js\n    var ImageUI = class extends BackendUI {\n      constructor() {\n        super(new ImageBackend(), \"Image\");\n      }\n      get format() {\n        return this.node.querySelector(\".format\");\n      }\n      async save() {\n        let url = await this.backend.save(this.format.value);\n        this.backend.download(url);\n      }\n      load() {\n      }\n    };\n  \n    // .js/backend/gdrive.js\n    var SCOPE = \"https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/drive.install\";\n    var CLIENT_ID = \"767837575056-h87qmlhmhb3djhaaqta5gv2v3koa9hii.apps.googleusercontent.com\";\n    var API_KEY = \"AIzaSyCzu1qVxlgufneOYpBgDJXN6Z9SNVcHYWM\";\n    var GDrive = class extends Backend {\n      constructor() {\n        super(\"gdrive\");\n        this.fileId = null;\n      }\n      reset() {\n        this.fileId = null;\n      }\n      async save(data, name, mime) {\n        await connect();\n        this.fileId = await this.send(data, name, mime);\n      }\n      send(data, name, mime) {\n        var path = \"/upload/drive/v2/files\";\n        var method = \"POST\";\n        if (this.fileId) {\n          path += \"/\" + this.fileId;\n          method = \"PUT\";\n        }\n        var boundary = \"b\" + Math.random();\n        var delimiter = \"--\" + boundary;\n        var body = [\n          delimiter,\n          \"Content-Type: application/json\",\n          \"\",\n          JSON.stringify({ title: name }),\n          delimiter,\n          \"Content-Type: \" + mime,\n          \"\",\n          data,\n          delimiter + \"--\"\n        ].join(\"\\r\\n\");\n        var request = gapi.client.request({\n          path,\n          method,\n          headers: {\n            \"Content-Type\": \"multipart/mixed; boundary='\" + boundary + \"'\"\n          },\n          body\n        });\n        return new Promise((resolve, reject) => {\n          request.execute((response) => {\n            if (!response) {\n              reject(new Error(\"Failed to upload to Google Drive\"));\n            } else if (response.error) {\n              reject(response.error);\n            } else {\n              resolve(response.id);\n            }\n          });\n        });\n      }\n      async load(id) {\n        await connect();\n        this.fileId = id;\n        var request = gapi.client.request({\n          path: \"/drive/v2/files/\" + this.fileId,\n          method: \"GET\"\n        });\n        return new Promise((resolve, reject) => {\n          request.execute(async (response) => {\n            if (!response || !response.id) {\n              return reject(response && response.error || new Error(\"Failed to download file\"));\n            }\n            let headers = { \"Authentication\": \"Bearer \" + gapi.auth.getToken().access_token };\n            let r = await fetch(`https://www.googleapis.com/drive/v2/files/${response.id}?alt=media`, { headers });\n            let data = await r.text();\n            if (r.status != 200) {\n              return reject(data);\n            }\n            resolve({ data, name: response.title, mime: response.mimeType });\n          });\n        });\n      }\n      async pick() {\n        await connect();\n        var token = gapi.auth.getToken();\n        var mimeTypes = [\"application/json; charset=UTF-8\", \"application/json\"];\n        [...repo6.values()].forEach((format) => {\n          if (format.mime) {\n            mimeTypes.unshift(format.mime);\n          }\n        });\n        var view = new google.picker.DocsView(google.picker.ViewId.DOCS).setMimeTypes(mimeTypes.join(\",\")).setMode(google.picker.DocsViewMode.LIST);\n        return new Promise((resolve) => {\n          let picker = new google.picker.PickerBuilder().enableFeature(google.picker.Feature.NAV_HIDDEN).addView(view).setOAuthToken(token.access_token).setDeveloperKey(API_KEY).setCallback((data) => {\n            switch (data[google.picker.Response.ACTION]) {\n              case google.picker.Action.PICKED:\n                var doc = data[google.picker.Response.DOCUMENTS][0];\n                resolve(doc.id);\n                break;\n              case google.picker.Action.CANCEL:\n                resolve(null);\n                break;\n            }\n          }).build();\n          picker.setVisible(true);\n        });\n      }\n    };\n    async function connect() {\n      if (\"gapi\" in window && gapi.auth.getToken()) {\n        return;\n      } else {\n        await loadGapi();\n        return auth();\n      }\n    }\n    function loadGapi() {\n      if (\"gapi\" in window) {\n        return;\n      }\n      let script = document.createElement(\"script\");\n      let name = (\"cb\" + Math.random()).replace(\".\", \"\");\n      script.src = \"https://apis.google.com/js/client:picker.js?onload=\" + name;\n      document.body.append(script);\n      return new Promise((resolve) => window[name] = resolve);\n    }\n    async function auth(forceUI = false) {\n      return new Promise((resolve, reject) => {\n        gapi.auth.authorize({\n          \"client_id\": CLIENT_ID,\n          \"scope\": SCOPE,\n          \"immediate\": !forceUI\n        }, async (token) => {\n          if (token && !token.error) {\n            resolve();\n          } else if (!forceUI) {\n            try {\n              await auth(true);\n              resolve();\n            } catch (e) {\n              reject(e);\n            }\n          } else {\n            reject(token && token.error || new Error(\"Failed to authorize with Google\"));\n          }\n        });\n      });\n    }\n  \n    // .js/ui/backend/gdrive.js\n    var GDriveUI = class extends BackendUI {\n      constructor() {\n        super(new GDrive(), \"Google Drive\");\n        fill(this.format);\n        this.format.value = localStorage.getItem(`${this.prefix}.format`) || \"native\";\n      }\n      get format() {\n        return this.node.querySelector(\".format\");\n      }\n      async save() {\n        setThrobber(true);\n        let format = repo6.get(this.format.value);\n        let json = currentMap.toJSON();\n        let data = format.to(json);\n        let name = currentMap.name;\n        let mime = \"text/plain\";\n        if (format.mime) {\n          mime = format.mime;\n        } else {\n          name += \".\" + format.extension;\n        }\n        try {\n          await this.backend.save(data, name, mime);\n          this.saveDone();\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      async load() {\n        setThrobber(true);\n        try {\n          let id = await this.backend.pick();\n          this.picked(id);\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      async picked(id) {\n        setThrobber(false);\n        if (!id) {\n          return;\n        }\n        setThrobber(true);\n        try {\n          let data = await this.backend.load(id);\n          let format = getByMime(data.mime) || getByName(data.name) || repo6.get(\"native\");\n          let json = format.from(data.data);\n          this.loadDone(json);\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      setState(data) {\n        this.picked(data.id);\n      }\n      getState() {\n        let data = {\n          b: this.id,\n          id: this.backend.fileId\n        };\n        return data;\n      }\n    };\n  \n    // .js/backend/firebase.js\n    var Firebase = class extends Backend {\n      constructor() {\n        super(\"firebase\");\n        this.current = {\n          id: null,\n          name: null,\n          data: null\n        };\n      }\n      connect(server, auth2) {\n        var config = {\n          apiKey: \"AIzaSyBO_6uCK8pHjoz1c9htVwZi6Skpm8o4LtQ\",\n          authDomain: \"my-mind.firebaseapp.com\",\n          databaseURL: \"https://\" + server + \".firebaseio.com\",\n          projectId: \"firebase-my-mind\",\n          storageBucket: \"firebase-my-mind.appspot.com\",\n          messagingSenderId: \"666556281676\"\n        };\n        firebase.initializeApp(config);\n        this.ref = firebase.database().ref();\n        this.ref.child(\"names\").on(\"value\", (snap) => {\n          publish(\"firebase-list\", this, snap.val() || {});\n        }, this);\n        if (auth2) {\n          return this.login(auth2);\n        }\n      }\n      save(data, id, name) {\n        this.ref.child(\"names/\" + id).set(name);\n        return new Promise((resolve, reject) => {\n          this.ref.child(\"data/\" + id).set(data, (err) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n              this.listenStart(data, id);\n            }\n          });\n        });\n      }\n      load(id) {\n        return new Promise((resolve, reject) => {\n          this.ref.child(\"data/\" + id).once(\"value\", (snap) => {\n            var data = snap.val();\n            if (data) {\n              resolve(data);\n              this.listenStart(data, id);\n            } else {\n              reject(new Error(\"There is no such saved map\"));\n            }\n          });\n        });\n      }\n      remove(id) {\n        this.ref.child(\"names/\" + id).remove();\n        return new Promise((resolve, reject) => {\n          this.ref.child(\"data/\" + id).remove((err) => {\n            err ? reject(err) : resolve();\n          });\n        });\n      }\n      reset() {\n        this.listenStop();\n      }\n      mergeWith(data, name) {\n        let id = this.current.id;\n        if (name != this.current.name) {\n          this.current.name = name;\n          this.ref.child(\"names/\" + id).set(name);\n        }\n        var dataRef = this.ref.child(\"data/\" + id);\n        var oldData = this.current.data;\n        this.listenStop();\n        this.recursiveRefMerge(dataRef, oldData, data);\n        this.listenStart(data, id);\n      }\n      recursiveRefMerge(ref, oldData, newData) {\n        let updateObject = {};\n        if (newData instanceof Array) {\n          for (var i = 0; i < newData.length; i++) {\n            var newValue = newData[i];\n            if (!(i in oldData)) {\n              updateObject[i] = newValue;\n            } else if (typeof newValue == \"object\") {\n              this.recursiveRefMerge(ref.child(i), oldData[i], newValue);\n            } else if (newValue !== oldData[i]) {\n              updateObject[i] = newValue;\n            }\n          }\n          for (var i = newData.length; i < oldData.length; i++) {\n            updateObject[i] = null;\n          }\n        } else {\n          for (var p in newData) {\n            var newValue = newData[p];\n            if (!(p in oldData)) {\n              updateObject[p] = newValue;\n            } else if (typeof newValue == \"object\") {\n              this.recursiveRefMerge(ref.child(p), oldData[p], newValue);\n            } else if (newValue !== oldData[p]) {\n              updateObject[p] = newValue;\n            }\n          }\n          for (var p in oldData) {\n            if (!(p in newData)) {\n              updateObject[p] = null;\n            }\n          }\n        }\n        if (Object.keys(updateObject).length) {\n          ref.update(updateObject);\n        }\n      }\n      listenStart(data, id) {\n        if (this.current.id && this.current.id == id) {\n          return;\n        }\n        this.listenStop();\n        this.current.id = id;\n        this.current.data = data;\n        this.ref.child(\"data/\" + id).on(\"value\", this.onValueChange, this);\n      }\n      listenStop() {\n        if (!this.current.id) {\n          return;\n        }\n        this.ref.child(\"data/\" + this.current.id).off(\"value\");\n        this.current.id = null;\n        this.current.name = null;\n        this.current.data = null;\n      }\n      onValueChange(snap) {\n        this.current.data = snap.val();\n        clearTimeout(this.changeTimeout);\n        this.changeTimeout = setTimeout(() => {\n          publish(\"firebase-change\", this, this.current.data);\n        }, 200);\n      }\n      async login(type) {\n        var provider;\n        switch (type) {\n          case \"github\":\n            provider = new firebase.auth.GithubAuthProvider();\n            break;\n          case \"facebook\":\n            provider = new firebase.auth.FacebookAuthProvider();\n            break;\n          case \"twitter\":\n            provider = new firebase.auth.TwitterAuthProvider();\n            break;\n          case \"google\":\n            provider = new firebase.auth.GoogleAuthProvider();\n            break;\n        }\n        let result = await firebase.auth().signInWithPopup(provider);\n        return result.user;\n      }\n    };\n  \n    // .js/ui/backend/firebase.js\n    var FirebaseUI = class extends BackendUI {\n      constructor() {\n        super(new Firebase(), \"Firebase\");\n        this.online = false;\n        const { server, auth: auth2, remove, go } = this;\n        server.value = localStorage.getItem(`${this.prefix}.server`) || \"my-mind\";\n        auth2.value = localStorage.getItem(`${this.prefix}.auth`) || \"\";\n        go.disabled = false;\n        remove.addEventListener(\"click\", async (_) => {\n          var id = this.list.value;\n          if (!id) {\n            return;\n          }\n          setThrobber(true);\n          try {\n            await this.backend.remove(id);\n            setThrobber(false);\n          } catch (e) {\n            this.error(e);\n          }\n        });\n        subscribe(\"firebase-list\", this);\n        subscribe(\"firebase-change\", this);\n      }\n      get auth() {\n        return this.node.querySelector(\".auth\");\n      }\n      get server() {\n        return this.node.querySelector(\".server\");\n      }\n      get remove() {\n        return this.node.querySelector(\".remove\");\n      }\n      get list() {\n        return this.node.querySelector(\".list\");\n      }\n      async setState(data) {\n        try {\n          await this.connect(data.s, data.a);\n          this.load(data.id);\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      getState() {\n        var data = {\n          id: currentMap.id,\n          b: this.id,\n          s: this.server.value\n        };\n        if (this.auth.value) {\n          data.a = this.auth.value;\n        }\n        return data;\n      }\n      show(mode2) {\n        super.show(mode2);\n        this.sync();\n      }\n      handleMessage(message, _publisher, data) {\n        switch (message) {\n          case \"firebase-list\":\n            this.list.innerHTML = \"\";\n            if (Object.keys(data).length) {\n              buildList(data, this.list);\n            } else {\n              var o = document.createElement(\"option\");\n              o.innerHTML = \"(no maps saved)\";\n              this.list.appendChild(o);\n            }\n            this.sync();\n            break;\n          case \"firebase-change\":\n            if (data) {\n              unsubscribe(\"item-change\", this);\n              currentMap.mergeWith(data);\n              subscribe(\"item-change\", this);\n            } else {\n              console.log(\"remote data disappeared\");\n            }\n            break;\n          case \"item-change\":\n            clearTimeout(this.itemChangeTimeout);\n            this.itemChangeTimeout = setTimeout(() => this.onItemChange(), 200);\n            break;\n        }\n      }\n      reset() {\n        this.backend.reset();\n        unsubscribe(\"item-change\", this);\n      }\n      onItemChange() {\n        var map = currentMap;\n        this.backend.mergeWith(map.toJSON(), map.name);\n      }\n      submit() {\n        if (!this.online) {\n          this.connect(this.server.value, this.auth.value);\n          return;\n        }\n        super.submit();\n      }\n      async save() {\n        setThrobber(true);\n        var map = currentMap;\n        try {\n          await this.backend.save(map.toJSON(), map.id, map.name);\n          this.saveDone();\n          subscribe(\"item-change\", this);\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      async load(id = this.list.value) {\n        setThrobber(true);\n        try {\n          let data = await this.backend.load(id);\n          this.loadDone(data);\n          subscribe(\"item-change\", this);\n        } catch (e) {\n          this.error(e);\n        }\n      }\n      async connect(server, auth2) {\n        this.server.value = server;\n        this.auth.value = auth2 || \"\";\n        this.server.disabled = true;\n        this.auth.disabled = true;\n        localStorage.setItem(`${this.prefix}.server`, server);\n        localStorage.setItem(`${this.prefix}.auth`, auth2 || \"\");\n        this.go.disabled = true;\n        setThrobber(true);\n        await this.backend.connect(server, auth2);\n        setThrobber(false);\n        this.online = true;\n        this.sync();\n      }\n      sync() {\n        if (!this.online) {\n          this.go.textContent = \"Connect\";\n          return;\n        }\n        this.go.disabled = false;\n        if (this.mode == \"load\" && !this.list.value) {\n          this.go.disabled = true;\n        }\n        this.go.textContent = this.mode.charAt(0).toUpperCase() + this.mode.substring(1);\n      }\n    };\n  \n    // .js/ui/io.js\n    var currentMode = \"load\";\n    var currentBackend = null;\n    var node8 = document.querySelector(\"#io\");\n    var select6 = node8.querySelector(\"#backend\");\n    var PREFIX = \"mm.app\";\n    function isActive() {\n      return node8.contains(document.activeElement);\n    }\n    function init11() {\n      [LocalUI, FirebaseUI, GDriveUI, FileUI, WebDAVUI, ImageUI].forEach((ctor) => {\n        let bui = new ctor();\n        select6.append(bui.option);\n      });\n      select6.value = localStorage.getItem(`${PREFIX}.backend`) || \"file\";\n      select6.addEventListener(\"change\", syncBackend);\n      subscribe(\"map-new\", (_) => setCurrentBackend(null));\n      subscribe(\"save-done\", onDone);\n      subscribe(\"load-done\", onDone);\n    }\n    function onDone(_message, publisher) {\n      hide2();\n      setCurrentBackend(publisher);\n    }\n    function restore() {\n      let parts = {};\n      location.search.substring(1).split(\"&\").forEach((item) => {\n        let keyvalue = item.split(\"=\").map(decodeURIComponent);\n        parts[keyvalue[0]] = keyvalue[1];\n      });\n      if (\"map\" in parts) {\n        parts.url = parts.map;\n      }\n      if (\"url\" in parts && !(\"b\" in parts)) {\n        parts.b = \"webdav\";\n      }\n      let backend = repo4.get(parts.b);\n      if (backend) {\n        backend.setState(parts);\n        return;\n      }\n      if (parts.state) {\n        try {\n          var state = JSON.parse(parts.state);\n          if (state.action == \"open\") {\n            state = {\n              b: \"gdrive\",\n              id: state.ids[0]\n            };\n            repo4.get(\"gdrive\").setState(state);\n          } else {\n            history.replaceState(null, \"\", \".\");\n          }\n        } catch (e) {\n        }\n        return;\n      }\n      setThrobber(false);\n    }\n    function show(mode2) {\n      currentMode = mode2;\n      node8.hidden = false;\n      node8.querySelector(\"h3\").textContent = mode2;\n      syncBackend();\n    }\n    function hide2() {\n      node8.hidden = true;\n    }\n    function quickSave() {\n      if (currentBackend) {\n        currentBackend.save();\n      } else {\n        show(\"save\");\n      }\n    }\n    function syncBackend() {\n      [...node8.querySelectorAll(\"div[id]\")].forEach((node11) => node11.hidden = true);\n      node8.querySelector(`#${select6.value}`).hidden = false;\n      repo4.get(select6.value).show(currentMode);\n    }\n    function setCurrentBackend(backend) {\n      if (currentBackend && currentBackend != backend) {\n        currentBackend.reset();\n      }\n      if (backend) {\n        localStorage.setItem(`${PREFIX}.backend`, backend.id);\n      }\n      currentBackend = backend;\n      try {\n        updateURL();\n      } catch (e) {\n      }\n    }\n    function updateURL() {\n      let data = currentBackend && currentBackend.getState();\n      if (!data) {\n        history.replaceState(null, \"\", \".\");\n      } else {\n        let arr = Object.entries(data).map((pair) => pair.map(encodeURIComponent).join(\"=\"));\n        history.replaceState(null, \"\", \"?\" + arr.join(\"&\"));\n      }\n    }\n  \n    // .js/ui/context-menu.js\n    var node9 = document.querySelector(\"#context-menu\");\n    var port;\n    function init12(port_) {\n      port = port_;\n      [...node9.querySelectorAll(\"[data-command]\")].forEach((button) => {\n        let commandName = button.dataset.command;\n        button.textContent = repo.get(commandName).label;\n      });\n      port.addEventListener(\"mousedown\", handleEvent);\n      node9.addEventListener(\"mousedown\", handleEvent);\n      close3();\n    }\n    function open(point) {\n      node9.hidden = false;\n      let w = node9.offsetWidth;\n      let h = node9.offsetHeight;\n      let left = point[0];\n      let top = point[1];\n      if (left > port.offsetWidth / 2) {\n        left -= w;\n      }\n      if (top > port.offsetHeight / 2) {\n        top -= h;\n      }\n      node9.style.left = `${left}px`;\n      node9.style.top = `${top}px`;\n    }\n    function handleEvent(e) {\n      if (e.currentTarget != node9) {\n        close3();\n        return;\n      }\n      e.stopPropagation();\n      e.preventDefault();\n      let commandName = e.target.dataset.command;\n      if (!commandName) {\n        return;\n      }\n      let command = repo.get(commandName);\n      if (!command.isValid) {\n        return;\n      }\n      command.execute();\n      close3();\n    }\n    function close3() {\n      node9.hidden = true;\n    }\n  \n    // .js/ui/ui.js\n    var node10 = document.querySelector(\"#ui\");\n    function isActive2() {\n      return node10.contains(document.activeElement) || isActive();\n    }\n    function toggle3() {\n      node10.hidden = !node10.hidden;\n      publish(\"ui-change\");\n    }\n    function getWidth() {\n      return node10.hidden ? 0 : node10.offsetWidth;\n    }\n    function update6() {\n      [layout_exports, shape_exports, icon_exports, value_exports, status_exports].forEach((ui5) => ui5.update());\n    }\n    function onClick3(e) {\n      let target = e.target;\n      if (target == node10.querySelector(\"#toggle\")) {\n        toggle3();\n        return;\n      }\n      let current2 = target;\n      while (true) {\n        let command = current2.dataset.command;\n        if (command) {\n          repo.get(command).execute();\n          return;\n        }\n        if (current2.parentNode instanceof Element) {\n          current2 = current2.parentNode;\n        } else {\n          return;\n        }\n      }\n    }\n    function init13(port4) {\n      [\n        layout_exports,\n        shape_exports,\n        icon_exports,\n        value_exports,\n        status_exports,\n        color_exports,\n        text_color_exports,\n        help_exports,\n        tip_exports,\n        notes_exports,\n        io_exports\n      ].forEach((ui5) => ui5.init());\n      init12(port4);\n      subscribe(\"item-select\", update6);\n      subscribe(\"item-change\", (_message, publisher) => {\n        if (publisher == currentItem) {\n          update6();\n        }\n      });\n      node10.addEventListener(\"click\", onClick3);\n      restore();\n    }\n  \n    // .js/command/command.js\n    var PAN_AMOUNT = 15;\n    function isMac() {\n      return !!navigator.platform.match(/mac/i);\n    }\n    var repo = new Map();\n    var Command = class {\n      constructor(id, label) {\n        this.label = label;\n        this.editMode = false;\n        repo.set(id, this);\n      }\n      get isValid() {\n        return this.editMode === null || this.editMode == editing;\n      }\n    };\n    new class Notes extends Command {\n      constructor() {\n        super(\"notes\", \"Notes\");\n        this.keys = [{ code: \"KeyM\", ctrlKey: true }];\n      }\n      execute() {\n        toggle2();\n      }\n    }();\n    new class Undo extends Command {\n      constructor() {\n        super(\"undo\", \"Undo\");\n        this.keys = [{ code: \"KeyZ\", ctrlKey: true }];\n      }\n      get isValid() {\n        return super.isValid && canBack();\n      }\n      execute() {\n        back();\n      }\n    }();\n    new class Redo extends Command {\n      constructor() {\n        super(\"redo\", \"Redo\");\n        this.keys = [{ code: \"KeyY\", ctrlKey: true }];\n      }\n      get isValid() {\n        return super.isValid && canForward();\n      }\n      execute() {\n        forward();\n      }\n    }();\n    new class InsertSibling extends Command {\n      constructor() {\n        super(\"insert-sibling\", \"Insert a sibling\");\n        this.keys = [{ code: \"Enter\" }];\n      }\n      execute() {\n        let item = currentItem;\n        let action2;\n        if (item.isRoot) {\n          action2 = new InsertNewItem(item, item.children.length);\n        } else {\n          let parent = item.parent;\n          let index2 = parent.children.indexOf(item);\n          action2 = new InsertNewItem(parent, index2 + 1);\n        }\n        action(action2);\n        repo.get(\"edit\").execute();\n        publish(\"command-sibling\");\n      }\n    }();\n    new class InsertChild extends Command {\n      constructor() {\n        super(\"insert-child\", \"Insert a child\");\n        this.keys = [\n          { code: \"Tab\", ctrlKey: false },\n          { code: \"Insert\" }\n        ];\n      }\n      execute() {\n        let item = currentItem;\n        let action2 = new InsertNewItem(item, item.children.length);\n        action(action2);\n        repo.get(\"edit\").execute();\n        publish(\"command-child\");\n      }\n    }();\n    new class Delete extends Command {\n      constructor() {\n        super(\"delete\", \"Delete an item\");\n        this.keys = [{ code: isMac() ? \"Backspace\" : \"Delete\" }];\n      }\n      get isValid() {\n        return super.isValid && !currentItem.isRoot;\n      }\n      execute() {\n        let action2 = new RemoveItem(currentItem);\n        action(action2);\n      }\n    }();\n    new class Swap2 extends Command {\n      constructor() {\n        super(\"swap\", \"Swap sibling\");\n        this.keys = [\n          { code: \"ArrowUp\", ctrlKey: true },\n          { code: \"ArrowDown\", ctrlKey: true }\n        ];\n      }\n      execute(e) {\n        let current2 = currentItem;\n        if (current2.isRoot || current2.parent.children.length < 2) {\n          return;\n        }\n        let diff = e.code == \"ArrowUp\" ? -1 : 1;\n        let action2 = new Swap(current2, diff);\n        action(action2);\n      }\n    }();\n    new class SetSide2 extends Command {\n      constructor() {\n        super(\"side\", \"Change side\");\n        this.keys = [\n          { code: \"ArrowLeft\", ctrlKey: true },\n          { code: \"ArrowRight\", ctrlKey: true }\n        ];\n      }\n      execute(e) {\n        let current2 = currentItem;\n        if (current2.isRoot || !current2.parent.isRoot) {\n          return;\n        }\n        let side = e.code == \"ArrowLeft\" ? \"left\" : \"right\";\n        let action2 = new SetSide(currentItem, side);\n        action(action2);\n      }\n    }();\n    new class Save extends Command {\n      constructor() {\n        super(\"save\", \"Save map\");\n        this.keys = [{ code: \"KeyS\", ctrlKey: true, shiftKey: false }];\n      }\n      execute() {\n        quickSave();\n      }\n    }();\n    new class SaveAs extends Command {\n      constructor() {\n        super(\"save-as\", \"Save as\\u2026\");\n        this.keys = [{ code: \"KeyS\", ctrlKey: true, shiftKey: true }];\n      }\n      execute() {\n        show(\"save\");\n      }\n    }();\n    new class Load extends Command {\n      constructor() {\n        super(\"load\", \"Load map\");\n        this.keys = [{ code: \"KeyO\", ctrlKey: true }];\n      }\n      execute() {\n        show(\"load\");\n      }\n    }();\n    new class Center extends Command {\n      constructor() {\n        super(\"center\", \"Center map\");\n        this.keys = [{ code: \"End\" }];\n      }\n      execute() {\n        currentMap.center();\n      }\n    }();\n    new class New extends Command {\n      constructor() {\n        super(\"new\", \"New map\");\n        this.keys = [{ code: \"KeyN\", ctrlKey: true }];\n      }\n      execute() {\n        if (!confirm(\"Throw away your current map and start a new one?\")) {\n          return;\n        }\n        showMap(new Map2());\n        publish(\"map-new\", this);\n      }\n    }();\n    new class ZoomIn extends Command {\n      constructor() {\n        super(\"zoom-in\", \"Zoom in\");\n        this.keys = [{ key: \"+\" }];\n      }\n      execute() {\n        currentMap.adjustFontSize(1);\n      }\n    }();\n    new class ZoomOut extends Command {\n      constructor() {\n        super(\"zoom-out\", \"Zoom out\");\n        this.keys = [{ key: \"-\" }];\n      }\n      execute() {\n        currentMap.adjustFontSize(-1);\n      }\n    }();\n    new class Help extends Command {\n      constructor() {\n        super(\"help\", \"Show/hide help\");\n        this.keys = [{ key: \"?\" }];\n      }\n      execute() {\n        toggle();\n      }\n    }();\n    new class UI extends Command {\n      constructor() {\n        super(\"ui\", \"Show/hide UI\");\n        this.keys = [{ key: \"*\" }];\n      }\n      execute() {\n        toggle3();\n      }\n    }();\n    new class Pan extends Command {\n      constructor() {\n        super(\"pan\", \"Pan the map\");\n        this.keys = [\n          { code: \"KeyW\", ctrlKey: false, altKey: false, metaKey: false },\n          { code: \"KeyA\", ctrlKey: false, altKey: false, metaKey: false },\n          { code: \"KeyS\", ctrlKey: false, altKey: false, metaKey: false },\n          { code: \"KeyD\", ctrlKey: false, altKey: false, metaKey: false }\n        ];\n        this.codes = [];\n      }\n      execute(e) {\n        const { code } = e;\n        var index2 = this.codes.indexOf(code);\n        if (index2 > -1) {\n          return;\n        }\n        if (!this.codes.length) {\n          window.addEventListener(\"keyup\", this);\n          this.interval = setInterval(() => this.step(), 50);\n        }\n        this.codes.push(code);\n        this.step();\n      }\n      step() {\n        const dirs = {\n          \"KeyW\": [0, 1],\n          \"KeyA\": [1, 0],\n          \"KeyS\": [0, -1],\n          \"KeyD\": [-1, 0]\n        };\n        let offset = [0, 0];\n        this.codes.forEach((code) => {\n          offset[0] += dirs[code][0] * PAN_AMOUNT;\n          offset[1] += dirs[code][1] * PAN_AMOUNT;\n        });\n        currentMap.moveBy(offset);\n      }\n      handleEvent(e) {\n        const { code } = e;\n        var index2 = this.codes.indexOf(code);\n        if (index2 > -1) {\n          this.codes.splice(index2, 1);\n          if (!this.codes.length) {\n            window.removeEventListener(\"keyup\", this);\n            clearInterval(this.interval);\n          }\n        }\n      }\n    }();\n    new class Fold extends Command {\n      constructor() {\n        super(\"fold\", \"Fold/Unfold\");\n        this.keys = [{ key: \"f\", ctrlKey: false }];\n      }\n      execute() {\n        let item = currentItem;\n        item.collapsed = !item.collapsed;\n        currentMap.ensureItemVisibility(item);\n      }\n    }();\n  \n    // .js/item.js\n    var TOGGLE_SIZE = 6;\n    var UPDATE_OPTIONS = {\n      parent: true,\n      children: false\n    };\n    var Item = class {\n      constructor() {\n        this._id = generateId();\n        this._parent = null;\n        this._collapsed = false;\n        this._icon = \"\";\n        this._notes = \"\";\n        this._color = \"\";\n        this._textColor = \"\";\n        this._value = null;\n        this._status = null;\n        this._side = null;\n        this._shape = new Box();\n        this._layout = null;\n        this.originalText = \"\";\n        this.dom = {\n          node: group(),\n          connectors: group(),\n          content: node(\"div\"),\n          notes: node(\"div\"),\n          status: node(\"span\"),\n          icon: node(\"span\"),\n          value: node(\"span\"),\n          text: node(\"div\"),\n          toggle: buildToggle()\n        };\n        this.children = [];\n        const { dom } = this;\n        dom.node.classList.add(\"item\");\n        dom.content.classList.add(\"content\");\n        dom.notes.classList.add(\"notes\");\n        dom.status.classList.add(\"status\");\n        dom.icon.classList.add(\"icon\");\n        dom.value.classList.add(\"value\");\n        dom.text.classList.add(\"text\");\n        dom.icon.classList.add(\"icon\");\n        this.notes = \"\";\n        let fo = foreignObject();\n        dom.node.append(dom.connectors, fo);\n        fo.append(dom.content);\n        dom.content.append(dom.status, dom.value, dom.icon, dom.text, dom.notes);\n        dom.toggle.addEventListener(\"click\", (_) => {\n          this.collapsed = !this.collapsed;\n          selectItem(this);\n        });\n        this.updateToggle();\n      }\n      static fromJSON(data) {\n        return new this().fromJSON(data);\n      }\n      get id() {\n        return this._id;\n      }\n      get parent() {\n        return this._parent;\n      }\n      set parent(parent) {\n        this._parent = parent;\n        this.update({ children: true });\n      }\n      get size() {\n        const bbox = this.dom.node.getBBox();\n        return [bbox.width, bbox.height];\n      }\n      get position() {\n        const { node: node11 } = this.dom;\n        const transform = node11.getAttribute(\"transform\");\n        return transform.match(/\\d+/g).map(Number);\n      }\n      set position(position) {\n        const { node: node11 } = this.dom;\n        const transform = `translate(${position.join(\" \")})`;\n        node11.setAttribute(\"transform\", transform);\n      }\n      get contentSize() {\n        const { content } = this.dom;\n        const fo = content.parentNode;\n        return [fo.getAttribute(\"width\"), fo.getAttribute(\"height\")].map(Number);\n      }\n      get contentPosition() {\n        const { content } = this.dom;\n        const fo = content.parentNode;\n        return [fo.getAttribute(\"x\"), fo.getAttribute(\"y\")].map(Number);\n      }\n      set contentPosition(position) {\n        const { content } = this.dom;\n        const fo = content.parentNode;\n        fo.setAttribute(\"x\", String(position[0]));\n        fo.setAttribute(\"y\", String(position[1]));\n      }\n      toJSON() {\n        let data = {\n          id: this.id,\n          text: this.text,\n          notes: this.notes\n        };\n        if (this._side) {\n          data.side = this._side;\n        }\n        if (this._color) {\n          data.color = this._color;\n        }\n        if (this._textColor) {\n          data.textColor = this._textColor;\n        }\n        if (this._icon) {\n          data.icon = this._icon;\n        }\n        if (this._value !== null) {\n          data.value = this._value;\n        }\n        if (this._status !== null) {\n          data.status = this._status;\n        }\n        if (this._layout) {\n          data.layout = this._layout.id;\n        }\n        if (this._shape) {\n          data.shape = this._shape.id;\n        }\n        if (this._collapsed) {\n          data.collapsed = true;\n        }\n        if (this.children.length) {\n          data.children = this.children.map((child) => child.toJSON());\n        }\n        return data;\n      }\n      fromJSON(data) {\n        this.text = data.text;\n        if (data.id) {\n          this._id = data.id;\n        }\n        if (data.notes) {\n          this.notes = data.notes;\n        }\n        if (data.side) {\n          this._side = data.side;\n        }\n        if (data.color) {\n          this._color = data.color;\n        }\n        if (data.textColor) {\n          this._textColor = data.textColor;\n        }\n        if (data.icon) {\n          this._icon = data.icon;\n        }\n        if (data.value !== void 0) {\n          this._value = data.value;\n        }\n        if (data.status !== void 0) {\n          if (data.status == \"yes\") {\n            this._status = true;\n          } else if (data.status == \"no\") {\n            this._status = false;\n          } else {\n            this._status = data.status;\n          }\n        }\n        if (data.collapsed) {\n          this.collapsed = !!data.collapsed;\n        }\n        if (data.layout) {\n          this._layout = repo2.get(data.layout);\n        }\n        if (data.shape) {\n          this.shape = repo3.get(data.shape);\n        }\n        (data.children || []).forEach((child) => {\n          this.insertChild(Item.fromJSON(child));\n        });\n        return this;\n      }\n      mergeWith(data) {\n        var dirty = 0;\n        if (this.text != data.text && !this.dom.text.contentEditable) {\n          this.text = data.text;\n        }\n        if (this._side != data.side) {\n          this._side = data.side || null;\n          dirty = 1;\n        }\n        if (this._color != data.color) {\n          this._color = data.color || \"\";\n          dirty = 2;\n        }\n        if (this._textColor != data.textColor) {\n          this._textColor = data.textColor || \"\";\n          dirty = 2;\n        }\n        if (this._icon != data.icon) {\n          this._icon = data.icon || \"\";\n          dirty = 1;\n        }\n        if (this._value != data.value) {\n          this._value = data.value || null;\n          dirty = 1;\n        }\n        if (this._status != data.status) {\n          this._status = data.status;\n          dirty = 1;\n        }\n        if (this._collapsed != !!data.collapsed) {\n          this.collapsed = !!data.collapsed;\n        }\n        let ourShapeId = this._shape ? this._shape.id : null;\n        if (ourShapeId != data.shape) {\n          this._shape = data.shape ? repo3.get(data.shape) : null;\n          dirty = 1;\n        }\n        let ourLayoutId = this._layout ? this._layout.id : null;\n        if (ourLayoutId != data.layout) {\n          this._layout = data.layout ? repo2.get(data.layout) : null;\n          dirty = 2;\n        }\n        (data.children || []).forEach((child, index2) => {\n          if (index2 >= this.children.length) {\n            this.insertChild(Item.fromJSON(child));\n          } else {\n            var myChild = this.children[index2];\n            if (myChild.id == child.id) {\n              myChild.mergeWith(child);\n            } else {\n              this.removeChild(this.children[index2]);\n              this.insertChild(Item.fromJSON(child), index2);\n            }\n          }\n        });\n        let newLength = (data.children || []).length;\n        while (this.children.length > newLength) {\n          this.removeChild(this.children[this.children.length - 1]);\n        }\n        if (dirty == 1) {\n          this.update({ children: false });\n        }\n        if (dirty == 2) {\n          this.update({ children: true });\n        }\n      }\n      clone() {\n        var data = this.toJSON();\n        var removeId = function(obj) {\n          delete obj.id;\n          obj.children && obj.children.forEach(removeId);\n        };\n        removeId(data);\n        return Item.fromJSON(data);\n      }\n      select() {\n        this.dom.node.classList.add(\"current\");\n        publish(\"item-select\", this);\n      }\n      deselect() {\n        this.dom.node.classList.remove(\"current\");\n      }\n      update(options = {}) {\n        options = Object.assign({}, UPDATE_OPTIONS, options);\n        const { map, children, parent } = this;\n        if (!map || !map.isVisible) {\n          return;\n        }\n        if (options.children) {\n          let childUpdateOptions = { parent: false, children: true };\n          children.forEach((child) => child.update(childUpdateOptions));\n        }\n        publish(\"item-change\", this);\n        this.updateStatus();\n        this.updateIcon();\n        this.updateValue();\n        const { resolvedLayout, resolvedShape, dom } = this;\n        const { content, node: node11, connectors } = dom;\n        dom.text.style.color = this.resolvedTextColor;\n        node11.dataset.shape = resolvedShape.id;\n        node11.dataset.align = resolvedLayout.computeAlignment(this);\n        let fo = content.parentNode;\n        let size = [\n          Math.max(content.offsetWidth, content.scrollWidth),\n          Math.max(content.offsetHeight, content.scrollHeight)\n        ];\n        fo.setAttribute(\"width\", String(size[0]));\n        fo.setAttribute(\"height\", String(size[1]));\n        connectors.innerHTML = \"\";\n        resolvedLayout.update(this);\n        resolvedShape.update(this);\n        if (options.parent && parent) {\n          parent.update({ children: false });\n        }\n      }\n      get text() {\n        return this.dom.text.innerHTML;\n      }\n      set text(text) {\n        let url_here=text.toString();\n        console.log(\"rawat\",url_here)\n        // this.dom.text.innerHTML = '<a target=\"_blank\" style=\"color:white;text-align:center\" href=' +url_here+'>'+text+'</a>';\n        this.dom.text.innerHTML=text;\n        \n        findLinks(this.dom.text);\n        this.update();\n      }\n      get notes() {\n        return this._notes;\n      }\n      set notes(notes3) {\n        this._notes = notes3;\n        this.dom.notes.hidden = !notes3;\n      }\n      get collapsed() {\n        return this._collapsed;\n      }\n      set collapsed(collapsed) {\n        this._collapsed = collapsed;\n        this.updateToggle();\n        let children = !collapsed;\n        this.update({ children });\n      }\n      get value() {\n        return this._value;\n      }\n      set value(value) {\n        this._value = value;\n        this.update();\n      }\n      get resolvedValue() {\n        const value = this._value;\n        if (typeof value == \"number\") {\n          return value;\n        }\n        let childValues = this.children.map((child) => child.resolvedValue);\n        switch (value) {\n          case \"max\":\n            return Math.max(...childValues);\n            break;\n          case \"min\":\n            return Math.min(...childValues);\n            break;\n          case \"sum\":\n            return childValues.reduce((prev, cur) => prev + cur, 0);\n            break;\n          case \"avg\":\n            var sum = childValues.reduce((prev, cur) => prev + cur, 0);\n            return childValues.length ? sum / childValues.length : 0;\n            break;\n          default:\n            return 0;\n            break;\n        }\n      }\n      get status() {\n        return this._status;\n      }\n      set status(status) {\n        this._status = status;\n        this.update();\n      }\n      get resolvedStatus() {\n        let status = this._status;\n        if (status == \"computed\") {\n          return this.children.every((child) => {\n            return child.resolvedStatus !== false;\n          });\n        } else {\n          return status;\n        }\n      }\n      get icon() {\n        return this._icon;\n      }\n      set icon(icon) {\n        this._icon = icon;\n        this.update();\n      }\n      get side() {\n        return this._side;\n      }\n      set side(side) {\n        this._side = side;\n      }\n      get color() {\n        return this._color;\n      }\n      set color(color) {\n        this._color = color;\n        this.update({ children: true });\n      }\n      get resolvedColor() {\n        if (this._color) {\n          return this._color;\n        }\n        const { parent } = this;\n        if (parent instanceof Item) {\n          return parent.resolvedColor;\n        }\n        return COLOR;\n      }\n      get textColor() {\n        return this._textColor;\n      }\n      set textColor(textColor) {\n        this._textColor = textColor;\n        this.update({ children: true });\n      }\n      get resolvedTextColor() {\n        if (this._textColor) {\n          return this._textColor;\n        }\n        const { parent } = this;\n        if (parent instanceof Item) {\n          return parent.resolvedTextColor;\n        }\n        return \"\";\n      }\n      get layout() {\n        return this._layout;\n      }\n      set layout(layout) {\n        this._layout = layout;\n        this.update({ children: true });\n      }\n      get resolvedLayout() {\n        if (this._layout) {\n          return this._layout;\n        }\n        const { parent } = this;\n        if (!(parent instanceof Item)) {\n          throw new Error(\"Non-connected item does not have layout\");\n        }\n        return parent.resolvedLayout;\n      }\n      get shape() {\n        return this._shape;\n      }\n      set shape(shape) {\n        this._shape = shape;\n        this.update();\n      }\n      get resolvedShape() {\n        if (this._shape) {\n          return this._shape;\n        }\n        let depth = 0;\n        let node11 = this;\n        while (!node11.isRoot) {\n          depth++;\n          node11 = node11.parent;\n        }\n        switch (depth) {\n          case 0:\n            return repo3.get(\"ellipse\");\n          case 1:\n            return repo3.get(\"box\");\n          default:\n            return repo3.get(\"underline\");\n        }\n      }\n      get map() {\n        let item = this.parent;\n        while (item) {\n          if (item instanceof Map2) {\n            return item;\n          }\n          item = item.parent;\n        }\n        return null;\n      }\n      get isRoot() {\n        return this.parent instanceof Map2;\n      }\n      insertChild(child, index2) {\n        child.originalText=\"tanu\";\n        if (!child) {\n          child = new Item();\n          child.originalText=\"tanu\";\n        } else if (child.parent && child.parent instanceof Item) {\n          //child.parent.removeChild(child);\n        }\n        if (!this.children.length) {\n          this.dom.node.appendChild(this.dom.toggle);\n        }\n        if (index2 === void 0) {\n          index2 = this.children.length;\n        }\n        var next = null;\n        if (index2 < this.children.length) {\n          next = this.children[index2].dom.node;\n        }\n        this.dom.node.insertBefore(child.dom.node, next);\n        this.children.splice(index2, 0, child);\n        child.parent = this;\n        \n      }\n      removeChild(child) {\n        var index2 = this.children.indexOf(child);\n        //this.children.splice(index2, 1);\n        //child.dom.node.remove();\n        //child.parent = null;\n        //!this.children.length && this.dom.toggle.remove();\n        //this.update();\n      }\n      startEditing() {\n        this.originalText = this.text;\n        this.dom.text.contentEditable = \"true\";\n        this.dom.text.focus();\n        document.execCommand(\"styleWithCSS\", false, \"false\");\n        this.dom.text.addEventListener(\"input\", this);\n        this.dom.text.addEventListener(\"keydown\", this);\n        this.dom.text.addEventListener(\"blur\", this);\n      }\n      stopEditing() {\n        this.dom.text.removeEventListener(\"input\", this);\n        this.dom.text.removeEventListener(\"keydown\", this);\n        this.dom.text.removeEventListener(\"blur\", this);\n        this.dom.text.blur();\n        this.dom.text.contentEditable = \"false\";\n        let result = this.dom.text.innerHTML;\n        this.dom.text.innerHTML = this.originalText;\n        this.originalText = \"\";\n        this.update();\n        return result;\n      }\n      handleEvent(e) {\n        switch (e.type) {\n          case \"input\":\n            this.update();\n            this.map.ensureItemVisibility(this);\n            break;\n          case \"keydown\":\n            if (e.code == \"Tab\") {\n              e.preventDefault();\n            }\n            break;\n          case \"blur\":\n            repo.get(\"finish\").execute();\n            break;\n        }\n      }\n      updateStatus() {\n        const { resolvedStatus, dom } = this;\n        dom.status.className = \"status\";\n        dom.status.hidden = false;\n        switch (resolvedStatus) {\n          case true:\n            dom.status.classList.add(\"yes\");\n            break;\n          case false:\n            dom.status.classList.add(\"no\");\n            break;\n          default:\n            dom.status.hidden = true;\n            break;\n        }\n      }\n      updateIcon() {\n        var icon = this._icon;\n        this.dom.icon.className = \"icon\";\n        this.dom.icon.hidden = !icon;\n        if (icon) {\n          this.dom.icon.classList.add(\"fa\");\n          this.dom.icon.classList.add(icon);\n        }\n      }\n      updateValue() {\n        const { dom, _value } = this;\n        if (_value === null) {\n          dom.value.hidden = true;\n          return;\n        }\n        dom.value.hidden = false;\n        if (typeof _value == \"number\") {\n          dom.value.textContent = String(_value);\n        } else {\n          let resolved = this.resolvedValue;\n          dom.value.textContent = String(Math.round(resolved) == resolved ? resolved : resolved.toFixed(3));\n        }\n      }\n      updateToggle() {\n        const { node: node11, toggle: toggle4 } = this.dom;\n        node11.classList.toggle(\"collapsed\", this._collapsed);\n        toggle4.querySelector(\"path\").setAttribute(\"d\", this._collapsed ? D_PLUS : D_MINUS);\n      }\n    };\n    function findLinks(node11) {\n      let children = [...node11.childNodes];\n      for (let i = 0; i < children.length; i++) {\n        let child = children[i];\n        if (child instanceof Element) {\n          if (child.nodeName.toLowerCase() == \"a\") {\n            continue;\n          }\n          findLinks(child);\n        }\n        if (child instanceof Text) {\n          let str = child.nodeValue;\n          let result = str.match(RE);\n          if (!result) {\n            continue;\n          }\n          let before = str.substring(0, result.index);\n          let after = str.substring(result.index + result[0].length);\n          var link = document.createElement(\"a\");\n          link.innerHTML = link.href = result[0];\n          link.setAttribute(\"style\", \"text-decoration:none\");\n\n\n          if (before) {\n            node11.insertBefore(document.createTextNode(before), child);\n          }\n          node11.insertBefore(link, child);\n          if (after) {\n            child.nodeValue = after;\n            i--;\n          } else {\n            child.remove();\n          }\n        }\n      }\n    }\n    function generateId() {\n      let str = \"\";\n      for (var i = 0; i < 8; i++) {\n        let code = Math.floor(Math.random() * 26);\n        str += String.fromCharCode(\"a\".charCodeAt(0) + code);\n      }\n      return str;\n    }\n    var D_MINUS = `M ${-(TOGGLE_SIZE - 2)} 0 L ${TOGGLE_SIZE - 2} 0`;\n    var D_PLUS = `${D_MINUS} M 0 ${-(TOGGLE_SIZE - 2)} L 0 ${TOGGLE_SIZE - 2}`;\n    function buildToggle() {\n      const circleAttrs = { \"cx\": \"0\", \"cy\": \"0\", \"r\": String(TOGGLE_SIZE) };\n      let g = group();\n      g.classList.add(\"toggle\");\n      g.append(node2(\"circle\", circleAttrs), node2(\"path\"));\n      return g;\n    }\n    var COLOR = \"#999\";\n    var RE = /\\b(([a-z][\\w-]+:\\/\\/\\w)|(([\\w-]+\\.){2,}[a-z][\\w-]+)|([\\w-]+\\.[a-z][\\w-]+\\/))[^\\s]*([^\\s,.;:?!<>\\(\\)\\[\\]'\"])?($|\\b)/i;\n  \n    // .js/map.js\n    var css = \"\";\n    var UPDATE_OPTIONS2 = {\n      children: true\n    };\n    var Map2 = class {\n      constructor(options) {\n        this.node = node2(\"svg\");\n        this.style = node(\"style\");\n        this.position = [0, 0];\n        this.fontSize = 15;\n        let resolvedOptions = Object.assign({\n          root: \"My Mind Map\",\n          layout: repo2.get(\"map\")\n        }, options);\n        this.style.textContent = css;\n        this.node.style.fontSize = `${this.fontSize}px`;\n        let root = new Item();\n        root.text = resolvedOptions.root;\n        root.layout = resolvedOptions.layout;\n        this.root = root;\n      }\n      static fromJSON(data) {\n        return new this().fromJSON(data);\n      }\n      toJSON() {\n        let data = {\n          root: this._root.toJSON()\n        };\n        return data;\n      }\n      fromJSON(data) {\n        this.root = Item.fromJSON(data.root);\n        return this;\n      }\n      get root() {\n        return this._root;\n      }\n      set root(root) {\n        const { node: node11, style } = this;\n        this._root = root;\n        node11.innerHTML = \"\";\n        node11.append(root.dom.node, style);\n        root.parent = this;\n      }\n      adjustFontSize(diff) {\n        this.fontSize = Math.max(8, this.fontSize + 2 * diff);\n        this.node.style.fontSize = `${this.fontSize}px`;\n        this.update();\n        this.ensureItemVisibility(currentItem);\n      }\n      mergeWith(data) {\n        let ids = [];\n        var current2 = currentItem;\n        var node11 = current2;\n        while (true) {\n          ids.push(node11.id);\n          if (node11.parent == this) {\n            break;\n          }\n          node11 = node11.parent;\n        }\n        this._root.mergeWith(data.root);\n        if (current2.map) {\n          let node12 = current2;\n          let hidden = false;\n          while (true) {\n            if (node12.parent == this) {\n              break;\n            }\n            node12 = node12.parent;\n            if (node12.collapsed) {\n              hidden = true;\n            }\n          }\n          if (!hidden) {\n            return;\n          }\n        }\n        editing && stopEditing();\n        var idMap = {};\n        var scan = function(item) {\n          idMap[item.id] = item;\n          item.children.forEach(scan);\n        };\n        scan(this._root);\n        while (ids.length) {\n          var id = ids.shift();\n          if (id in idMap) {\n            selectItem(idMap[id]);\n            return;\n          }\n        }\n      }\n      get isVisible() {\n        return !!this.node.parentNode;\n      }\n      update(options) {\n        options = Object.assign({}, UPDATE_OPTIONS2, options);\n        options.children && this._root.update({ parent: false, children: true });\n        const { node: node11 } = this;\n        const { size } = this._root;\n        node11.setAttribute(\"width\", String(size[0]));\n        node11.setAttribute(\"height\", String(size[1]));\n      }\n      show(where) {\n        where.append(this.node);\n        this.update();\n        this.center();\n        selectItem(this._root);\n      }\n      hide() {\n        this.node.remove();\n      }\n      center() {\n        let { size } = this._root;\n        let parent = this.node.parentNode;\n        let position = [\n          (parent.offsetWidth - size[0]) / 2,\n          (parent.offsetHeight - size[1]) / 2\n        ].map(Math.round);\n        this.moveTo(position);\n      }\n      moveBy(diff) {\n        let position = this.position.map((p, i) => p + diff[i]);\n        return this.moveTo(position);\n      }\n      getClosestItem(point) {\n        let all2 = [];\n        function scan(item) {\n          let rect = item.dom.content.getBoundingClientRect();\n          let dx = rect.left + rect.width / 2 - point[0];\n          let dy = rect.top + rect.height / 2 - point[1];\n          let distance = dx * dx + dy * dy;\n          all2.push({ dx, dy, item, distance });\n          if (!item.collapsed) {\n            item.children.forEach(scan);\n          }\n        }\n        scan(this._root);\n        all2.sort((a, b) => a.distance - b.distance);\n        return all2[0];\n      }\n      getItemFor(node11) {\n        let content = node11.closest(\".content\");\n        if (!content) {\n          return;\n        }\n        function scanForContent(item) {\n          if (item.dom.content == content) {\n            return item;\n          }\n          for (let child of item.children) {\n            let found = scanForContent(child);\n            if (found) {\n              return found;\n            }\n          }\n        }\n        return scanForContent(this._root);\n      }\n      ensureItemVisibility(item) {\n        const padding = 10;\n        let itemRect = item.dom.content.getBoundingClientRect();\n        var parentRect = this.node.parentNode.getBoundingClientRect();\n        var delta = [0, 0];\n        var dx = parentRect.left - itemRect.left + padding;\n        if (dx > 0) {\n          delta[0] = dx;\n        }\n        var dx = parentRect.right - itemRect.right - padding;\n        if (dx < 0) {\n          delta[0] = dx;\n        }\n        var dy = parentRect.top - itemRect.top + padding;\n        if (dy > 0) {\n          delta[1] = dy;\n        }\n        var dy = parentRect.bottom - itemRect.bottom - padding;\n        if (dy < 0) {\n          delta[1] = dy;\n        }\n        if (delta[0] || delta[1]) {\n          this.moveBy(delta);\n        }\n      }\n      get name() {\n        let name = this._root.text;\n        return br2nl(name).replace(/\\n/g, \" \").replace(/<.*?>/g, \"\").trim();\n      }\n      get id() {\n        return this._root.id;\n      }\n      pick(item, direction) {\n        let candidates = [];\n        var currentRect = item.dom.content.getBoundingClientRect();\n        this.getPickCandidates(currentRect, this._root, direction, candidates);\n        if (!candidates.length) {\n          return item;\n        }\n        candidates.sort((a, b) => a.dist - b.dist);\n        return candidates[0].item;\n      }\n      getPickCandidates(currentRect, item, direction, candidates) {\n        if (!item.collapsed) {\n          item.children.forEach((child) => {\n            this.getPickCandidates(currentRect, child, direction, candidates);\n          });\n        }\n        var node11 = item.dom.content;\n        var rect = node11.getBoundingClientRect();\n        if (direction == \"left\" || direction == \"right\") {\n          var x1 = currentRect.left + currentRect.width / 2;\n          var x2 = rect.left + rect.width / 2;\n          if (direction == \"left\" && x2 > x1) {\n            return;\n          }\n          if (direction == \"right\" && x2 < x1) {\n            return;\n          }\n          var diff1 = currentRect.top - rect.bottom;\n          var diff2 = rect.top - currentRect.bottom;\n          var dist = Math.abs(x2 - x1);\n        } else {\n          var y1 = currentRect.top + currentRect.height / 2;\n          var y2 = rect.top + rect.height / 2;\n          if (direction == \"top\" && y2 > y1) {\n            return;\n          }\n          if (direction == \"bottom\" && y2 < y1) {\n            return;\n          }\n          var diff1 = currentRect.left - rect.right;\n          var diff2 = rect.left - currentRect.right;\n          var dist = Math.abs(y2 - y1);\n        }\n        var diff = Math.max(diff1, diff2);\n        if (diff > 0) {\n          return;\n        }\n        if (!dist || dist < diff) {\n          return;\n        }\n        candidates.push({ item, dist });\n      }\n      moveTo(point) {\n        this.position = point;\n        this.node.style.left = `${point[0]}px`;\n        this.node.style.top = `${point[1]}px`;\n      }\n    };\n    async function init14() {\n      let response = await fetch(\"map.css\");\n      css = await response.text();\n    }\n  \n    // .js/keyboard.js\n    function handleEvent2(e) {\n      if (isActive2()) {\n        return;\n      }\n      let command = [...repo.values()].find((command2) => {\n        if (!command2.isValid) {\n          return false;\n        }\n        return command2.keys.find((key) => keyOK(key, e));\n      });\n      if (command) {\n        e.preventDefault();\n        command.execute(e);\n      }\n    }\n    function init15() {\n      window.addEventListener(\"keydown\", handleEvent2);\n    }\n    function keyOK(key, e) {\n      return Object.entries(key).every(([key2, value]) => e[key2] == value);\n    }\n  \n    // .js/mouse.js\n    var TOUCH_DELAY = 500;\n    var SHADOW_OFFSET = 5;\n    var touchContextTimeout;\n    var current = {\n      mode: \"\",\n      cursor: [],\n      item: null,\n      ghost: null,\n      ghostPosition: [],\n      previousDragState: null\n    };\n    var port2;\n    function init16(port_) {\n      port2 = port_;\n      port2.addEventListener(\"touchstart\", onDragStart);\n      port2.addEventListener(\"mousedown\", onDragStart);\n      port2.addEventListener(\"click\", (e) => {\n        let item = currentMap.getItemFor(e.target);\n        if (editing && item == currentItem) {\n          return;\n        }\n        item && selectItem(item);\n      });\n      port2.addEventListener(\"dblclick\", (e) => {\n        let item = currentMap.getItemFor(e.target);\n        item && repo.get(\"edit\").execute();\n      });\n      port2.addEventListener(\"wheel\", (e) => {\n        const { deltaY } = e;\n        if (!deltaY) {\n          return;\n        }\n        let dir = deltaY > 0 ? -1 : 1;\n        currentMap.adjustFontSize(dir);\n      });\n      port2.addEventListener(\"contextmenu\", (e) => {\n        onDragEnd(e);\n        e.preventDefault();\n        let item = currentMap.getItemFor(e.target);\n        item && selectItem(item);\n        open([e.clientX, e.clientY]);\n      });\n    }\n    function onDragStart(e) {\n      let point = eventToPoint(e);\n      if (!point) {\n        return;\n      }\n      let item = currentMap.getItemFor(e.target);\n      if (editing) {\n        if (item == currentItem) {\n          return;\n        }\n        repo.get(\"finish\").execute();\n      }\n      document.activeElement.blur();\n      current.cursor = point;\n      if (item && !item.isRoot) {\n        current.mode = \"drag\";\n        current.item = item;\n      } else {\n        current.mode = \"pan\";\n        port2.style.cursor = \"move\";\n      }\n      if (e.type == \"mousedown\") {\n        e.preventDefault();\n        port2.addEventListener(\"mousemove\", onDragMove);\n        port2.addEventListener(\"mouseup\", onDragEnd);\n      }\n      if (e.type == \"touchstart\") {\n        touchContextTimeout = setTimeout(function() {\n          item && selectItem(item);\n          open(point);\n        }, TOUCH_DELAY);\n        port2.addEventListener(\"touchmove\", onDragMove);\n        port2.addEventListener(\"touchend\", onDragEnd);\n      }\n    }\n    function onDragMove(e) {\n      let point = eventToPoint(e);\n      if (!point) {\n        return;\n      }\n      clearTimeout(touchContextTimeout);\n      e.preventDefault();\n      let delta = [\n        point[0] - current.cursor[0],\n        point[1] - current.cursor[1]\n      ];\n      current.cursor = point;\n      switch (current.mode) {\n        case \"drag\":\n          if (!current.ghost) {\n            port2.style.cursor = \"move\";\n            buildGhost(current.item);\n          }\n          moveGhost(delta);\n          let state = computeDragState();\n          visualizeDragState(state);\n          break;\n        case \"pan\":\n          currentMap.moveBy(delta);\n          break;\n      }\n    }\n    function onDragEnd(_e) {\n      clearTimeout(touchContextTimeout);\n      port2.style.cursor = \"\";\n      port2.removeEventListener(\"mousemove\", onDragMove);\n      port2.removeEventListener(\"mouseup\", onDragEnd);\n      const { mode: mode2, ghost } = current;\n      if (mode2 == \"pan\") {\n        return;\n      }\n      if (ghost) {\n        let state = computeDragState();\n        finishDragDrop(state);\n        ghost.remove();\n        current.ghost = null;\n      }\n      current.item = null;\n    }\n    function buildGhost(item) {\n      const { content } = item.dom;\n      let ghost = content.cloneNode(true);\n      ghost.classList.add(\"ghost\");\n      port2.append(ghost);\n      let rect = content.getBoundingClientRect();\n      current.ghost = ghost;\n      current.ghostPosition = [rect.left, rect.top];\n    }\n    function moveGhost(delta) {\n      let { ghostPosition } = current;\n      let ghost = current.ghost;\n      ghostPosition[0] += delta[0];\n      ghostPosition[1] += delta[1];\n      ghost.style.left = `${ghostPosition[0]}px`;\n      ghost.style.top = `${ghostPosition[1]}px`;\n    }\n    function finishDragDrop(state) {\n      visualizeDragState(null);\n      const { target, result, direction } = state;\n      let action2;\n      switch (result) {\n        case \"append\":\n          action2 = new MoveItem(current.item, target);\n          break;\n        case \"sibling\":\n          let targetChildItem = target;\n          let index2 = targetChildItem.parent.children.indexOf(targetChildItem);\n          let targetIndex = index2 + (direction == \"right\" || direction == \"bottom\" ? 1 : 0);\n          action2 = new MoveItem(current.item, targetChildItem.parent, targetIndex, targetChildItem.side);\n          break;\n        default:\n          return;\n          break;\n      }\n      action(action2);\n    }\n    function computeDragState() {\n      let rect = current.ghost.getBoundingClientRect();\n      let point = [rect.left + rect.width / 2, rect.top + rect.height / 2];\n      let closest = currentMap.getClosestItem(point);\n      let target = closest.item;\n      let state = {\n        result: \"\",\n        target,\n        direction: \"left\"\n      };\n      let tmp = target;\n      while (!tmp.isRoot) {\n        if (tmp == current.item) {\n          return state;\n        }\n        tmp = tmp.parent;\n      }\n      let itemContentSize = current.item.contentSize;\n      let targetContentSize = target.contentSize;\n      const w = Math.max(itemContentSize[0], targetContentSize[0]);\n      const h = Math.max(itemContentSize[1], targetContentSize[1]);\n      if (target.isRoot) {\n        state.result = \"append\";\n      } else if (Math.abs(closest.dx) < w && Math.abs(closest.dy) < h) {\n        state.result = \"append\";\n      } else {\n        state.result = \"sibling\";\n        let childDirection = target.parent.resolvedLayout.getChildDirection(target);\n        if (childDirection == \"left\" || childDirection == \"right\") {\n          state.direction = closest.dy < 0 ? \"bottom\" : \"top\";\n        } else {\n          state.direction = closest.dx < 0 ? \"right\" : \"left\";\n        }\n      }\n      return state;\n    }\n    function visualizeDragState(state) {\n      let { previousDragState } = current;\n      if (previousDragState && state && previousDragState.target == state.target && previousDragState.result == state.result) {\n        return;\n      }\n      if (previousDragState) {\n        previousDragState.target.dom.content.style.boxShadow = \"\";\n      }\n      if (!state) {\n        return;\n      }\n      let x = 0, y = 0;\n      if (state.result == \"sibling\") {\n        if (state.direction == \"left\") {\n          x = -1;\n        }\n        if (state.direction == \"right\") {\n          x = 1;\n        }\n        if (state.direction == \"top\") {\n          y = -1;\n        }\n        if (state.direction == \"bottom\") {\n          y = 1;\n        }\n      }\n      let spread = x || y ? -2 : 2;\n      state.target.dom.content.style.boxShadow = `${x * SHADOW_OFFSET}px ${y * SHADOW_OFFSET}px 2px ${spread}px #000`;\n      current.previousDragState = state;\n    }\n    function eventToPoint(e) {\n      if (\"touches\" in e) {\n        if (e.touches.length > 1) {\n          return null;\n        }\n        return [e.touches[0].clientX, e.touches[0].clientY];\n      } else {\n        return [e.clientX, e.clientY];\n      }\n    }\n  \n    // .js/clipboard.js\n    var storedItem = null;\n    var mode = \"\";\n    function init17() {\n      document.body.addEventListener(\"cut\", onCopyCut);\n      document.body.addEventListener(\"copy\", onCopyCut);\n      document.body.addEventListener(\"paste\", onPaste);\n    }\n    function onCopyCut(e) {\n      if (isActive2() || editing) {\n        return;\n      }\n      e.preventDefault();\n      endCut();\n      switch (e.type) {\n        case \"copy\":\n          storedItem = currentItem.clone();\n          break;\n        case \"cut\":\n          storedItem = currentItem;\n          storedItem.dom.node.classList.add(\"cut\");\n          break;\n        default:\n          return;\n      }\n      let json = storedItem.toJSON();\n      let plaintext = repo6.get(\"plaintext\").to(json);\n      e.clipboardData.setData(\"text/plain\", plaintext);\n      mode = e.type;\n    }\n    function onPaste(e) {\n      if (isActive2() || editing) {\n        return;\n      }\n      e.preventDefault();\n      let pasted = e.clipboardData.getData(\"text/plain\");\n      if (!pasted) {\n        return;\n      }\n      if (storedItem && pasted == repo6.get(\"plaintext\").to(storedItem.toJSON())) {\n        pasteItem(storedItem, currentItem);\n      } else {\n        pastePlaintext(pasted, currentItem);\n      }\n      endCut();\n    }\n    function pasteItem(sourceItem, targetItem) {\n      let action2;\n      switch (mode) {\n        case \"cut\":\n          if (sourceItem == targetItem || sourceItem.parent == targetItem) {\n            return;\n          }\n          let item = targetItem;\n          while (true) {\n            if (item == sourceItem) {\n              return;\n            }\n            if (item.parent instanceof Map2) {\n              break;\n            }\n            item = item.parent;\n          }\n          action2 = new MoveItem(sourceItem, targetItem);\n          action(action2);\n          break;\n        case \"copy\":\n          action2 = new AppendItem(targetItem, sourceItem.clone());\n          action(action2);\n          break;\n      }\n    }\n    function pastePlaintext(plaintext, targetItem) {\n      let json = repo6.get(\"plaintext\").from(plaintext);\n      let map = Map2.fromJSON(json);\n      let root = map.root;\n      if (root.text) {\n        let action2 = new AppendItem(targetItem, root);\n        action(action2);\n      } else {\n        let subactions = root.children.map((item) => new AppendItem(targetItem, item));\n        let action2 = new Multi(subactions);\n        action(action2);\n      }\n    }\n    function endCut() {\n      if (mode != \"cut\") {\n        return;\n      }\n      storedItem.dom.node.classList.remove(\"cut\");\n      storedItem = null;\n      mode = \"\";\n    }\n  \n    // .js/title.js\n    function onItemChange(_message, publisher) {\n      if (publisher.isRoot && publisher.map == currentMap) {\n        document.title = currentMap.name + \" :: My Mind\";\n      }\n    }\n    function init18() {\n      subscribe(\"item-change\", onItemChange);\n    }\n  \n    // .js/command/select.js\n    new class Select extends Command {\n      constructor() {\n        super(\"select\", \"Move selection\");\n        this.keys = [\n          { code: \"ArrowLeft\", ctrlKey: false },\n          { code: \"ArrowUp\", ctrlKey: false },\n          { code: \"ArrowRight\", ctrlKey: false },\n          { code: \"ArrowDown\", ctrlKey: false }\n        ];\n      }\n      execute(e) {\n        let dirs = {\n          \"ArrowLeft\": \"left\",\n          \"ArrowUp\": \"top\",\n          \"ArrowRight\": \"right\",\n          \"ArrowDown\": \"bottom\"\n        };\n        let dir = dirs[e.code];\n        let layout = currentItem.resolvedLayout;\n        let item = layout.pick(currentItem, dir);\n        selectItem(item);\n      }\n    }();\n    new class SelectRoot extends Command {\n      constructor() {\n        super(\"select-root\", \"Select root\");\n        this.keys = [{ code: \"Home\" }];\n      }\n      execute() {\n        let item = currentItem;\n        while (!item.isRoot) {\n          item = item.parent;\n        }\n        selectItem(item);\n      }\n    }();\n    \n    \n      new class SelectParent extends Command {\n        constructor() {\n          super(\"select-parent\", \"Select parent\");\n          this.keys = [{ code: \"Backspace\" }];\n        }\n        execute() {\n          if(currentItem.parent.isRoot)\n          return ;\n          let item = currentItem;\n        // while (item.id!=currentParent.id) {\n        //   item = item.parent;\n        // }\n        if(item!=undefined && !item.isRoot)\n          selectItem(item.parent);\n          console.log(\"parent\" ,item.parent.id)\n        }\n      }();\n    \n  \n    // .js/command/edit.js\n    new class Edit extends Command {\n      constructor() {\n        super(\"edit\", \"Edit item\");\n        this.keys = [\n          { code: \"Space\" },\n          { code: \"F2\" }\n        ];\n      }\n      execute() {\n\n        startEditing();\n      }\n    }();\n    new class Finish extends Command {\n      constructor() {\n        super(\"finish\", \"Finish editing\");\n        this.keys = [{ code: \"Enter\", altKey: false, ctrlKey: false, shiftKey: false }];\n        this.editMode = true;\n      }\n      execute(tabInfo) {\n        let text = stopEditing();\n        let title = \"\";\n        if(tabInfo && tabInfo.title)\n        {text=tabInfo.url;\n        title=tabInfo.title}\n        console.log(\"setting the currTitle here so that if its called with same title it doesnt come here it stops in callFinish it\")\n        currTitle=title\n        let action2;\n        if (text) {\n          //currentItem.notes = tabInfo.url\n          action2 = new SetText(currentItem, text);\n          debugger\n          \n          \n        } else {\n          action2 = new RemoveItem(currentItem);\n        }\n        action(action2);\n        currentItem.dom.node.getElementsByTagName('a')[0].innerHTML=title\n      }\n    }();\n    new class Newline extends Command {\n      constructor() {\n        super(\"newline\", \"Line break\");\n        this.keys = [\n          { code: \"Enter\", shiftKey: true },\n          { code: \"Enter\", ctrlKey: true }\n        ];\n        this.editMode = true;\n      }\n      execute() {\n        let range = getSelection().getRangeAt(0);\n        let br = document.createElement(\"br\");\n        range.insertNode(br);\n        range.setStartAfter(br);\n        currentItem.update({ parent: true, children: true });\n      }\n    }();\n    new class Cancel extends Command {\n      constructor() {\n        super(\"cancel\", \"Cancel\");\n        this.keys = [{ code: \"Escape\" }];\n        this.editMode = null;\n      }\n      execute() {\n        if (editing) {\n          stopEditing();\n          var oldText = currentItem.text;\n          if (!oldText) {\n            var action2 = new RemoveItem(currentItem);\n            action(action2);\n          }\n        } else {\n          close2();\n          close();\n          hide2();\n        }\n      }\n    }();\n    var Style = class extends Command {\n      constructor() {\n        super(...arguments);\n        this.editMode = null;\n      }\n      execute() {\n        if (editing) {\n          document.execCommand(this.command, false);\n        } else {\n          repo.get(\"edit\").execute();\n          let selection = getSelection();\n          let range = selection.getRangeAt(0);\n          range.selectNodeContents(currentItem.dom.text);\n          selection.removeAllRanges();\n          selection.addRange(range);\n          this.execute();\n          repo.get(\"finish\").execute();\n        }\n      }\n    };\n    new class Bold extends Style {\n      constructor() {\n        super(\"bold\", \"Bold\");\n        this.keys = [{ code: \"KeyB\", ctrlKey: true }];\n        this.command = \"bold\";\n      }\n    }();\n    new class Underline2 extends Style {\n      constructor() {\n        super(\"underline\", \"Underline\");\n        this.keys = [{ code: \"KeyU\", ctrlKey: true }];\n        this.command = \"underline\";\n      }\n    }();\n    new class Italic extends Style {\n      constructor() {\n        super(\"italic\", \"Italic\");\n        this.keys = [{ code: \"KeyI\", ctrlKey: true }];\n        this.command = \"italic\";\n      }\n    }();\n    new class Strikethrough extends Style {\n      constructor() {\n        super(\"strikethrough\", \"Strike-through\");\n        this.keys = [{ code: \"KeyS\", ctrlKey: true }];\n        this.command = \"strikeThrough\";\n      }\n    }();\n    new class Value extends Command {\n      constructor() {\n        super(\"value\", \"Set value\");\n        this.keys = [{ key: \"v\", ctrlKey: false, metaKey: false }];\n      }\n      execute() {\n        let item = currentItem;\n        let oldValue = item.value;\n        let newValue = prompt(\"Set item value\", String(oldValue));\n        if (newValue == null) {\n          return;\n        }\n        if (!newValue.length) {\n          newValue = null;\n        }\n        let numValue = Number(newValue);\n        let action2 = new SetValue(item, isNaN(numValue) ? newValue : numValue);\n        action(action2);\n      }\n    }();\n    new class Yes extends Command {\n      constructor() {\n        super(\"yes\", \"Yes\");\n        this.keys = [{ key: \"y\", ctrlKey: false }];\n      }\n      execute() {\n        let item = currentItem;\n        let status = item.status === true ? null : true;\n        let action2 = new SetStatus(item, status);\n        action(action2);\n      }\n    }();\n    new class No extends Command {\n      constructor() {\n        super(\"no\", \"No\");\n        this.keys = [{ key: \"n\", ctrlKey: false }];\n      }\n      execute() {\n        let item = currentItem;\n        let status = item.status === false ? null : false;\n        let action2 = new SetStatus(item, status);\n        action(action2);\n      }\n    }();\n    new class Computed extends Command {\n      constructor() {\n        super(\"computed\", \"Computed\");\n        this.keys = [{ key: \"c\", ctrlKey: false, metaKey: false }];\n      }\n      execute() {\n        let item = currentItem;\n        let status = item.status == \"computed\" ? null : \"computed\";\n        let action2 = new SetStatus(item, status);\n        action(action2);\n      }\n    }();\n\n    // .js/stack.js\n\n    class Node {\n      constructor(value){\n          this.value = value\n          this.next = null\n      }\n  \n  }\n  \n  \n  class Stack {\n      constructor(){\n          this.first = null\n          this.last = null\n          this.size = 0\n      }\n      push(value){\n        //create new node\n        let node = new Node(value)\n        \n        // check if the first node is valid\n        if(!this.first){\n          \n         //if not, make the new node the first and last node of the stack\n          this.first = node\n          this.last = node\n        }else{\n         // if there is at least one node in the stack\n         // make new node to be the first and the previous \n         // first node to be the next property of the new first \n           let temp = this.first\n           this.first = node\n           this.first.next = temp\n        }\n      \n       // increment the size\n       this.size++\n      \n      return this.size\n    }\n    pop(){\n    \n      // if there is no node return null\n      if(!this.first) return null\n      // if there are nodes\n      let temp = this.first\n      // if only one node, set the first to null\n      if(this.first === this.last){\n            this.last = null\n      }\n      \n      //set the first to be the next node\n      this.first = this.first.next\n     \n      //decrement the size\n      this.size--\n      \n      //return removed node value\n      return temp.value\n    \n    \n    \n    \n    }\n    \n  }\n  \n  \n  \n    // .js/my-mind.js\n    var port3 = document.querySelector(\"main\");\n    var throbber = document.querySelector(\"#throbber\");\n    var currentMap;\n    var currentItem;\n    var editing = false;\n    function showMap(map) {\n      currentMap && currentMap.hide();\n      reset();\n      currentMap = map;\n      currentMap.show(port3);\n    }\n    function action(action2) {\n      console.log(actions);\n      console.log(action2);\n      push(action2);\n      \n      action2.do();\n\n    }\n    function selectItem(item) {\n      if (currentItem && currentItem != item) {\n        if (editing) {\n          repo.get(\"finish\").execute();\n        }\n        currentItem.deselect();\n      }\n      if(item!=undefined){\n      currentItem = item;\n      currentItem.select();\n      currentMap.ensureItemVisibility(currentItem);}\n    }\n    function setThrobber(visible) {\n      throbber.hidden = !visible;\n    }\n    function startEditing() {\n      editing = true;\n      currentItem.startEditing();\n    }\n    function stopEditing() {\n      editing = false;\n      return currentItem.stopEditing();\n    }\n    async function init19() {\n      await init14();\n      subscribe(\"ui-change\", syncPort);\n      window.addEventListener(\"resize\", syncPort);\n      window.addEventListener(\"beforeunload\", (e) => {\n        e.preventDefault();\n        return \"\";\n      });\n      init17();\n      init15();\n      init16(port3);\n      init18();\n      init13(port3);\n      syncPort();\n      showMap(new Map2());\n    }\n\n     function callInsertChild(tabInfo) {\n        // ignore keyboard when the activeElement resides somewhere inside of the UI pane\n        if(tabInfo.title==null || tabInfo.title==\"\" ||current_tab_url==tabInfo.url)\n      return;\n        let command = repo.get(\"insert-child\") \n        let e=new KeyboardEvent(\"key\")\n        if (command) {\n        command.execute(e);\n        console.log(\"akash  successfully triggered an event\");\n        console.log(tabInfo)\n        }\n        //current_tab_url=tabInfo.url;\n    }\n     function callUpdateChild(tabInfo) {\n      if(!tabInfo.title)\n      return;\n      // ignore keyboard when the activeElement resides somewhere inside of the UI pane\n      let command = repo.get(\"edit\") \n      let e=new KeyboardEvent(\"key\")\n      if (command) {\n      command.execute(e);\n      console.log(\"dikhsha  successfully triggered an event\");\n      console.log(tabInfo)\n      current_tab_url=tabInfo.url;\n      }\n  }\n  async function callSelectRoot(){\n\n    let command = repo.get(\"select-root\")\n    let e=new KeyboardEvent(\"select root\")\n    if (command) {\n    command.execute();\n    console.log(\" selectted the root\");\n    //await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n  }\n\n}\nasync function callSelectParent(){\n\n  let command = repo.get(\"select-parent\")\n  let e=new KeyboardEvent(\"select parent\")\n  if (command) {\n  command.execute();\n  console.log(\" selectted the parent\");\n  //await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n}\n\n}\nvar currTitle=\"\"\n  function callFinishChild(tabInfo) {\n    // ignore keyboard when the activeElement resides somewhere inside of the UI pane\n    let command = repo.get(\"finish\")\n    let e=new KeyboardEvent(\"finish\")\n    if (command) {\n      //if(currTitle!=tabInfo.title)\n    command.execute(tabInfo);\n    \n    console.log(\"finishi  successfully triggered an event\");\n    console.log(tabInfo)\n    }\n}\n    function syncPort() {\n      let portSize = [window.innerWidth - getWidth(), window.innerHeight];\n      port3.style.width = portSize[0] + \"px\";\n      port3.style.height = portSize[1] + \"px\";\n      currentMap && currentMap.ensureItemVisibility(currentItem);\n    }\n    init19();\n    var current_tab_url=\"\";\n    var s=0;\n    let currentTabId=0;\n    var previousUrl=\"\";\n    async function handleUpdated(tabId, changeInfo, tabInfo) {\n      await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n      if (tabInfo.status == \"complete\" && tabInfo.active) { \n        \n        \n        // Perform you task after page loaded completely \n        if(tabInfo.title==null || tabInfo.title==\"\" || tabInfo.title==currTitle)\n        return;\n\n\n        if(tabStack.first!=null && tabStack.first.next!=null && ((tabStack.first.next.value.dom.node.getElementsByTagName('a')[0].href==tabInfo.url)||\n        (tabStack.first.value.dom.node.getElementsByTagName('a')[0].href==tabInfo.url)\n        )){\n\n\n          let node=tabStack.first;\n          let el=node.value;\n          let txt= el.dom.node.getElementsByTagName('a')[0].innerHTML\n          console.log(txt,\"the tab-title for topmost\");\n          if(currentItem.dom.node.getElementsByTagName('a')[0].href!=tabInfo.url)\n          callSelectParent();\n          await new Promise((resolve, reject) => setTimeout(resolve, 1000));\n          if(tabInfo.id!=undefined && tabInfo.id>0)\n          map1.set(tabInfo.id,currentItem);\n          \n          tabStack.pop();\n\n        }\n        else{\n          console.log(\"why child is added\",tabStack)\n          if(currentItem!=undefined)\n          tabStack.push(currentItem)\n          if(current_tab_url!=tabInfo.url)\n        {callInsertChild(tabInfo);\n        callUpdateChild(tabInfo);\n        callFinishChild(tabInfo);\n        await new Promise((resolve, reject) => setTimeout(resolve, 1000));\n        if(map1.has(tabInfo.id)){\n          map1.delete(tabInfo.id);\n\n        }\n          if(tabInfo.id!=undefined && tabInfo.id>0)\n          map1.set(tabInfo.id,currentItem);\n         \n        \n        //console.log(s++);\n      //counter++\n    }\n        }\n\n\n        console.log(`Updated tab: ${tabId}`);\n        console.log(\"Changed attributes: \", changeInfo);\n        console.log(\"New tab Info: \", tabInfo.title);\n        console.log(tabInfoCUrrent.title);\n        console.log(tabInfo.title);\n        flag=true\n        console.log(\"the following needs to be un equal baby\",currentTabId,tabInfo.id,tabId)\n        \n\n        if(!(currentTabId==tabInfo.id))\n        { callSelectRoot();\n          console.log(\"the following are the updated tab results and root is being decidded\")\n          console.log(currentTabId,tabInfo.id)\n        }\n        \n        \n          //callSelectParent();\n        \n        \n        \n        console.log(\"time started\")\n\n        //await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n\n        console.log(\"time ended\")\n        \n        //currentTabId=tabInfo.id;\n\n        previousUrl=tabInfo.url;\n      }\n\n      \n     \n\n      \n    }\n    var counter =0;\n    var tabStack=new Stack();\n    const map1 = new Map();\n    map1.set('a', 1);\n    map1.set('b', 2);\n    map1.set('c', 3);\n\nconsole.log(map1.get('a'));\n// Expected output: 1\n\nmap1.set('a', 97);\n\n    browser.tabs.onUpdated.addListener(handleUpdated);\n\n    async function logListener(info) {\n      try {\n         \n         tabInfoCUrrent = await browser.tabs.get(info.tabId);\n         currentTabId=tabInfoCUrrent.id\n         current_tab_url=tabInfoCUrrent.url;\n         \n         \n         if(map1.has(currentTabId)){\n          selectItem(map1.get(currentTabId));\n          await new Promise((resolve, reject) => setTimeout(resolve, 1000));\n\n         }\n         else\n         callSelectRoot();\n         \n        console.log(\"we activated a new tab with tanino\",currentTabId);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    \n    browser.tabs.onActivated.addListener(logListener);\n    \n  })();\n \n\n//# sourceURL=webpack:///./tabMap/tab-mind.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./tabMap/tab-mind.js"]();
/******/ 	
/******/ })()
;